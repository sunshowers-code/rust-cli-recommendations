<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rain&#x27;s Rust CLI recommendations</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        <meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@sunshowers6" />
<meta name="twitter:creator" content="@sunshowers6" />
<meta property="og:title" content="Rain&#x27;s Rust CLI recommendations" />
<meta property="og:url" content="https://rust-cli-recommendations.sunshowers.io/print.md" />
<meta property="og:image"
    content="https://user-images.githubusercontent.com/180618/150588951-9722aae0-2542-4962-9435-3dd621b32687.png" />
<meta property="og:description" content="Tips and best practices for writing and structuring Rust command-line programs." />

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Tips and best practices for writing and structuring Rust command-line programs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html">Introduction</a></li><li class="chapter-item expanded "><a href="cli-parser.html">Picking an argument parser</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="handling-arguments.html">Handling arguments and subcommands</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="binaries-vs-libraries.html">Binaries vs libraries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="machine-readable-output.html">Machine-readable output</a></li><li class="chapter-item expanded "><a href="organizing-binary.html">Organizing code in binary crates</a></li></ol></li><li class="chapter-item expanded "><a href="versioning.html">Versioning</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="colors.html">Adding colors to applications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="managing-colors-in-rust.html">Managing colors in Rust</a></li></ol></li><li class="chapter-item expanded "><a href="configuration.html">Configuration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hierarchical-config.html">Hierarchical configuration</a></li><li class="chapter-item expanded "><div>Merging command-line arguments and config files</div></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><div>Dry runs and the interpreter pattern</div></li><li class="chapter-item expanded "><div>Logging</div></li><li class="chapter-item expanded "><div>Error handling and exit codes</div></li><li class="chapter-item expanded "><div>Signal handling</div></li><li class="chapter-item expanded "><div>Atomic writes</div></li><li class="chapter-item expanded "><div>Locking and TOCTOU races</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="key-words.html">Key words</a></li><li class="chapter-item expanded affix "><a href="acknowledgments.html">Acknowledgments</a></li><li class="chapter-item expanded affix "><a href="changelog.html">Changelog</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rain&#x27;s Rust CLI recommendations</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sunshowers-code/rust-cli-recommendations" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rains-rust-cli-recommendations"><a class="header" href="#rains-rust-cli-recommendations">Rain's Rust CLI recommendations</a></h1>
<p>This living document comprises <a href="https://github.com/sunshowers">my</a> <a href="https://rust-cli-recommendations.sunshowers.io">recommendations</a>
for how to organize and manage Rust CLI applications.</p>
<p>In this document, I cover some tips and best practices for writing Rust applications, informed
<a href="https://sunshowers.io/work/#open-source-projects">by my experience</a> writing real-world Rust tools. I've focused on command-line tools here, but many of the suggestions can be generalized to graphical and server applications as well. I hope you find them useful for your own applications.</p>
<p>If you haven't gone through the <a href="https://rust-cli.github.io/book/index.html">Rust CLI Book</a> yet, I'd recommend reading it first. That book provides a lot of useful information about how to write command-line apps in Rust. This document covers some more advanced material and is more opinionated overall.</p>
<h2 id="locations"><a class="header" href="#locations">Locations</a></h2>
<p>This document is hosted online at <a href="https://rust-cli-recommendations.sunshowers.io">https://rust-cli-recommendations.sunshowers.io</a>. The source is hosted <a href="https://github.com/sunshowers-code/rust-cli-recommendations">on GitHub</a>.</p>
<p>This document is available offline by installing <code>git</code> and running the following command while online.</p>
<pre><code class="language-sh">git clone https://github.com/sunshowers-code/rust-cli-recommendations --branch gh-pages
</code></pre>
<p>then pointing your web browser at <code>rust-cli-recommendations/index.html</code>.</p>
<p>Pull requests to fix typos or unclear language are welcome! If you have a suggestion for a change to the document, please <a href="https://github.com/sunshowers-code/rust-cli-recommendations/issues?q=is%3Aissue+sort%3Aupdated-desc">search through the issues</a> to see if it's been discussed already. If not, please <a href="https://github.com/sunshowers-code/rust-cli-recommendations/issues/new">open an issue</a>.</p>
<blockquote>
<p>Tip: While reading the book, you can hit the edit button <i class="fa fa-edit"></i> in the top right corner to make a quick change to it.</p>
</blockquote>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>This document, other than inline code snippets, is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>. This means that you are welcome to share, adapt or modify this material as long as you give appropriate credit.</p>
<p>Code snippets included in this document are licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0 1.0</a>. The author(s) have waived all of their rights to the work worldwide under copyright law, to the extent allowed by law.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="picking-an-argument-parser"><a class="header" href="#picking-an-argument-parser">Picking an argument parser</a></h1>
<p>When you're writing a Rust command-line application, one of the first things you'll have to do is to figure out how to parse command-line inputs.
There are a number of different command-line parsers for Rust programs. However, projects <em>should</em> use <a href="https://crates.io/crates/clap"><strong>clap</strong></a>.</p>
<p><strong>Why?</strong></p>
<ul>
<li>clap is actively maintained: as of January 2022, clap just came out with a <a href="">v3 release</a>.</li>
<li>clap is the most popular command-line parsing library for Rust, which means that there's an existing ecosystem of projects around clap.</li>
<li>clap comes with a number of extra features, such as suggestions based on <a href="https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance">Jaro–Winkler distance</a> and full configurability of <a href="https://docs.rs/clap/latest/clap/enum.AppSettings.html">commands</a> and <a href="https://docs.rs/clap/latest/clap/enum.ArgSettings.html">arguments</a>.</li>
<li>There are a number of standard conventions for Unix CLIs: see <a href="https://github.com/google/argh/issues/3#issuecomment-581144181">this comment</a> by <a href="https://github.com/ssokolow">Stephen Sokolow</a>. clap supports all of them. Another actively maintained project, <a href="https://github.com/google/argh">argh</a>, does not target Unix platforms and so does not support all of these conventions.</li>
</ul>
<p><strong>Reasons against using clap</strong></p>
<ul>
<li>clap pulls in several dependencies and takes quite a while to build.</li>
<li>clap increases binary size significantly.</li>
<li>clap is a complex parser with many different options. I've found uses for most of them, but they can be overwhelming.</li>
<li>clap version 3 currently has a Minimum Supported Rust Version (MSRV) of Rust 1.54; I personally do not consider this to be a negative but there's <a href="https://github.com/clap-rs/clap/issues/3267">some discussions about it</a>. For now, a workaround is to use version 2 of clap, which supports most of the features that clap version 3 does.</li>
</ul>
<h2 id="automatically-deriving-arguments"><a class="header" href="#automatically-deriving-arguments">Automatically deriving arguments</a></h2>
<p>Projects <em>may</em> turn on the <code>derive</code> feature in clap and use a declarative model to define command-line arguments. (The <code>derive</code> feature is new to v3---users of clap v2 can use <a href="https://crates.io/crates/structopt">structopt</a>, which <code>clap_derive</code> is based on.)</p>
<p>For example:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// Run this binary with:
</span><span class="boring">//    cd code
</span><span class="boring">//    cargo run --bin grep-app -- &lt;arguments&gt;
</span><span class="boring">
</span>use clap::Parser;
use std::path::PathBuf;

/// A very simple utility to search for a string across multiple files.
#[derive(Debug, Parser)]
#[clap(name = &quot;grep-app&quot;, version = &quot;0.1.0&quot;, author = &quot;My Awesome Team&quot;)]
pub struct GrepApp {
    /// Suppress normal output; instead print the name of each input file from which output
    /// would normally have been printed.  Scanning each input file stops upon first match.
    #[clap(long, short = 'l')]
    files_with_matches: bool,

    /// Search string
    search_str: String,

    /// Input files
    files: Vec&lt;PathBuf&gt;,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    GrepApp::parse();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">const EXPECTED_HELP: &amp;str = r#&quot;grep-app 0.1.0
</span><span class="boring">My Awesome Team
</span><span class="boring">A very simple utility to search for a string across multiple files
</span><span class="boring">
</span><span class="boring">USAGE:
</span><span class="boring">    grep-app [OPTIONS] &lt;SEARCH_STR&gt; [FILES]...
</span><span class="boring">
</span><span class="boring">ARGS:
</span><span class="boring">    &lt;SEARCH_STR&gt;    Search string
</span><span class="boring">    &lt;FILES&gt;...      Input files
</span><span class="boring">
</span><span class="boring">OPTIONS:
</span><span class="boring">    -h, --help                  Print help information
</span><span class="boring">    -l, --files-with-matches    Suppress normal output; instead print the name of each input file
</span><span class="boring">                                from which output would normally have been printed.  Scanning each
</span><span class="boring">                                input file stops upon first match
</span><span class="boring">    -V, --version               Print version information
</span><span class="boring">&quot;#;
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use clap::IntoApp;
</span><span class="boring">    use std::io::Cursor;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_help() {
</span><span class="boring">        let mut app = GrepApp::into_app();
</span><span class="boring">        let mut cursor: Cursor&lt;Vec&lt;u8&gt;&gt; = Cursor::new(Vec::new());
</span><span class="boring">        app.write_help(&amp;mut cursor).unwrap();
</span><span class="boring">        let help = String::from_utf8(cursor.into_inner()).unwrap();
</span><span class="boring">        println!(&quot;{}&quot;, help);
</span><span class="boring">        assert_eq!(help, EXPECTED_HELP);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>The doc comments are processed as help text by clap. Here's what the help text looks like:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// Run this binary with:
</span><span class="boring">//    cd code
</span><span class="boring">//    cargo run --bin grep-app -- &lt;arguments&gt;
</span><span class="boring">
</span><span class="boring">use clap::Parser;
</span><span class="boring">use std::path::PathBuf;
</span><span class="boring">
</span><span class="boring">/// A very simple utility to search for a string across multiple files.
</span><span class="boring">#[derive(Debug, Parser)]
</span><span class="boring">#[clap(name = &quot;grep-app&quot;, version = &quot;0.1.0&quot;, author = &quot;My Awesome Team&quot;)]
</span><span class="boring">pub struct GrepApp {
</span><span class="boring">    /// Suppress normal output; instead print the name of each input file from which output
</span><span class="boring">    /// would normally have been printed.  Scanning each input file stops upon first match.
</span><span class="boring">    #[clap(long, short = 'l')]
</span><span class="boring">    files_with_matches: bool,
</span><span class="boring">
</span><span class="boring">    /// Search string
</span><span class="boring">    search_str: String,
</span><span class="boring">
</span><span class="boring">    /// Input files
</span><span class="boring">    files: Vec&lt;PathBuf&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    GrepApp::parse();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[allow(dead_code)]
</span>const EXPECTED_HELP: &amp;str = r#&quot;grep-app 0.1.0
My Awesome Team
A very simple utility to search for a string across multiple files

USAGE:
    grep-app [OPTIONS] &lt;SEARCH_STR&gt; [FILES]...

ARGS:
    &lt;SEARCH_STR&gt;    Search string
    &lt;FILES&gt;...      Input files

OPTIONS:
    -h, --help                  Print help information
    -l, --files-with-matches    Suppress normal output; instead print the name of each input file
                                from which output would normally have been printed.  Scanning each
                                input file stops upon first match
    -V, --version               Print version information
&quot;#;
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use clap::IntoApp;
</span><span class="boring">    use std::io::Cursor;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_help() {
</span><span class="boring">        let mut app = GrepApp::into_app();
</span><span class="boring">        let mut cursor: Cursor&lt;Vec&lt;u8&gt;&gt; = Cursor::new(Vec::new());
</span><span class="boring">        app.write_help(&amp;mut cursor).unwrap();
</span><span class="boring">        let help = String::from_utf8(cursor.into_inner()).unwrap();
</span><span class="boring">        println!(&quot;{}&quot;, help);
</span><span class="boring">        assert_eq!(help, EXPECTED_HELP);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p><strong>Why?</strong></p>
<ul>
<li>Derive-style arguments are significantly easier to read, write, and modify.</li>
<li>Derive-style components can be written once, and reused across multiple commands.</li>
</ul>
<p><strong>Why not?</strong></p>
<ul>
<li>The derive macro is an optional feature that pulls in extra dependencies and increases build times.</li>
<li>The derive macro can be a bit magical. Looking at <a href="https://github.com/clap-rs/clap/blob/master/clap_derive/src/lib.rs">the source code of clap_derive</a>, or the generated output with <a href="https://crates.io/crates/cargo-expand">cargo-expand</a>, may be useful.</li>
<li>The derive macro is less flexible than the builder API. For example, for an argument used multiple times like <code>-v -v -v</code>, the builder API can tell you exactly which position each <code>-v</code> was used in. The derive macro can only tell you how many times <code>-v</code> was used.</li>
</ul>
<blockquote>
<p>Tip: With clap 3, it is possible to combine the builder and derive approaches. For example, <a href="https://docs.rs/clap/3/clap/trait.Args.html#tymethod.augment_args_for_update"><code>clap::Args::augment_args_for_update</code></a> can be used to flatten a derived list of arguments into a builder-based <code>App</code>.</p>
</blockquote>
<h2 id="command-and-argument-case"><a class="header" href="#command-and-argument-case">Command and argument case</a></h2>
<p>Following Unix and GNU conventions, all commands and arguments, except for short arguments, <em>must</em> be in <a href="https://en.wikipedia.org/wiki/Kebab_case">kebab case</a>. This means that:</p>
<ul>
<li>Commands and arguments <em>must</em> be in lowercase.</li>
<li>Multiple words <em>must</em> be separated by hyphens: <code>--example-opt</code>, not <code>--example_opt</code> or <code>--exampleOpt</code>.</li>
</ul>
<p><code>clap</code>'s derive feature and <code>structopt</code> use kebab case by default. If you have an existing command that doesn't follow these rules, you can maintain compatibility by renaming it to the kebab-cased version and retaining the old case as an alias.</p>
<h2 id="alternatives-to-clap"><a class="header" href="#alternatives-to-clap">Alternatives to clap</a></h2>
<ul>
<li><a href="https://github.com/google/argh">argh</a>: Actively maintained, and has an explicit goal of being low-overhead at runtime. However, it <a href="https://github.com/google/argh/issues/3#issuecomment-581144934">follows Fuchsia OS conventions</a> rather than Unix ones, so it's missing several crucial features from a Unix perspective.</li>
<li><a href="https://github.com/RazrFalcon/pico-args">pico-args</a>: Zero dependencies, quick to compile, and negligible impact on binary size. Does not include help generation, derive support, or as many config flags as clap. A great choice for really simple applications.</li>
<li><a href="https://crates.io/crates/gumdrop">gumdrop</a>: a simple argument parser with derive support. Somewhat less popular than clap, and doesn't support deserializing directly to domain types (clap <a href="https://github.com/clap-rs/clap/blob/v3.0.6/examples/derive_ref/README.md#arg-types">does</a>).</li>
</ul>
<p>For a comparison of binary size overhead and build times between these parsers and more, see <a href="https://github.com/rust-cli/argparse-benchmarks-rs">these benchmarks</a>.</p>
<h2 id="writing-your-own-parser-by-hand"><a class="header" href="#writing-your-own-parser-by-hand">Writing your own parser by hand</a></h2>
<p>You <em>should not</em> write your own parser completely by hand. Instead, most cases are better served by a simple parser like <a href="https://github.com/RazrFalcon/pico-args">pico-args</a>.</p>
<p>If you must write a parser by hand, consider basing it on the <a href="https://docs.rs/lexopt/latest/lexopt/">lexopt</a> lexer. Be sure to handle all the <a href="https://github.com/google/argh/issues/3#issuecomment-581144181">standard conventions for Unix CLIs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-arguments-and-subcommands"><a class="header" href="#handling-arguments-and-subcommands">Handling arguments and subcommands</a></h1>
<p>For a program that has subcommands, the following code structure is <em>recommended</em>.</p>
<pre><code class="language-rust noplaypen"><span class="boring">// Run this binary with:
</span><span class="boring">//    cd code
</span><span class="boring">//    cargo run --bin grep-app -- &lt;arguments&gt;
</span><span class="boring">
</span>use camino::Utf8PathBuf;
use clap::{ArgEnum, Args, Parser, Subcommand};

/// Here's my app!
#[derive(Debug, Parser)]
#[clap(name = &quot;my-app&quot;, version)]
pub struct App {
    #[clap(flatten)]
    global_opts: GlobalOpts,

    #[clap(subcommand)]
    command: Command,
}

#[derive(Debug, Subcommand)]
enum Command {
    /// Help message for read.
    Read {
        /// An example option
        #[clap(long, short = 'o')]
        example_opt: bool,

        /// The path to read from
        path: Utf8PathBuf,
        // (can #[clap(flatten)] other argument structs here)
    },
    /// Help message for write.
    Write(WriteArgs),
    // ...other commands (can #[clap(flatten)] other enum variants here)
}

#[derive(Debug, Args)]
struct WriteArgs {
    /// The path to write to
    path: Utf8PathBuf,
    // a list of other write args
}

#[derive(Debug, Args)]
struct GlobalOpts {
    /// Color
    #[clap(long, arg_enum, global = true, default_value_t = Color::Auto)]
    color: Color,

    /// Verbosity level (can be specified multiple times)
    #[clap(long, short, global = true, parse(from_occurrences))]
    verbose: usize,
    //... other global options
}

#[derive(Clone, Debug, ArgEnum)]
enum Color {
    Always,
    Auto,
    Never,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let app = App::parse();
</span><span class="boring">    println!(
</span><span class="boring">        &quot;Verbosity level specified {} times&quot;,
</span><span class="boring">        app.global_opts.verbose
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">const EXPECTED_HELP: &amp;str = r#&quot;my-app 0.1.0
</span><span class="boring">Here's my app!
</span><span class="boring">
</span><span class="boring">USAGE:
</span><span class="boring">    my-app [OPTIONS] &lt;SUBCOMMAND&gt;
</span><span class="boring">
</span><span class="boring">OPTIONS:
</span><span class="boring">        --color &lt;COLOR&gt;    Color [default: auto] [possible values: always, auto, never]
</span><span class="boring">    -h, --help             Print help information
</span><span class="boring">    -v, --verbose          Verbosity level (can be specified multiple times)
</span><span class="boring">    -V, --version          Print version information
</span><span class="boring">
</span><span class="boring">SUBCOMMANDS:
</span><span class="boring">    help     Print this message or the help of the given subcommand(s)
</span><span class="boring">    read     Help message for read
</span><span class="boring">    write    Help message for write
</span><span class="boring">&quot;#;
</span><span class="boring">
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">const EXPECTED_READ_HELP: &amp;str = r#&quot;read 
</span><span class="boring">Help message for read
</span><span class="boring">
</span><span class="boring">USAGE:
</span><span class="boring">    read [OPTIONS] &lt;PATH&gt;
</span><span class="boring">
</span><span class="boring">ARGS:
</span><span class="boring">    &lt;PATH&gt;    The path to read from
</span><span class="boring">
</span><span class="boring">OPTIONS:
</span><span class="boring">    -h, --help           Print help information
</span><span class="boring">    -o, --example-opt    An example option
</span><span class="boring">&quot;#;
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use clap::IntoApp;
</span><span class="boring">    use std::io::Cursor;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_help() {
</span><span class="boring">        let mut app = App::into_app();
</span><span class="boring">        let mut cursor: Cursor&lt;Vec&lt;u8&gt;&gt; = Cursor::new(Vec::new());
</span><span class="boring">        app.write_help(&amp;mut cursor).unwrap();
</span><span class="boring">        let help = String::from_utf8(cursor.into_inner()).unwrap();
</span><span class="boring">        println!(&quot;{}&quot;, help);
</span><span class="boring">        assert_eq!(help, EXPECTED_HELP);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_read_help() {
</span><span class="boring">        let mut app = App::into_app();
</span><span class="boring">        let mut cursor: Cursor&lt;Vec&lt;u8&gt;&gt; = Cursor::new(Vec::new());
</span><span class="boring">        let read_cmd = app.find_subcommand_mut(&quot;read&quot;).unwrap();
</span><span class="boring">        read_cmd.write_help(&amp;mut cursor).unwrap();
</span><span class="boring">        let help = String::from_utf8(cursor.into_inner()).unwrap();
</span><span class="boring">        println!(&quot;{}&quot;, help);
</span><span class="boring">        assert_eq!(help, EXPECTED_READ_HELP);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Notes:</p>
<ul>
<li><strong>Only the top-level <code>App</code> is public.</strong></li>
<li><strong><code>App</code> is a struct, one level above the command enum.</strong>
<ul>
<li>While it is possible to make <code>App</code> an enum with all the subcommands, in my experience this design has always come back to bite me. This has always been because I've wanted to introduce global options later.</li>
</ul>
</li>
<li><strong>Liberal use of <code>#[clap(flatten)]</code>.</strong>
<ul>
<li>This option flattens inline options from a struct into the parent struct or enum variant, or from an enum into a parent enum.</li>
<li>This helps break up long series of options into smaller, reusable components that can be more easily processed in different sections of the project's code. For example, <code>Color</code> can be further nested into an <code>OutputOpts</code> struct, defined in a separate <code>output.rs</code> file.</li>
<li>It also helps code pass a complex set of arguments around as a single parameter, rather than having to add a parameter everywhere.</li>
</ul>
</li>
<li><strong>Global options are marked with <code>#[clap(global = true)]</code>.</strong>
<ul>
<li>This means that global options like <code>--color</code> can be used anywhere in the command line.</li>
</ul>
</li>
<li><strong>Use of <code>ArgEnum</code>.</strong>
<ul>
<li><code>ArgEnum</code> simplifies the definition of arguments that take one of a limited number of values.</li>
</ul>
</li>
</ul>
<hr />
<p>The top-level help message is:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// Run this binary with:
</span><span class="boring">//    cd code
</span><span class="boring">//    cargo run --bin grep-app -- &lt;arguments&gt;
</span><span class="boring">
</span><span class="boring">use camino::Utf8PathBuf;
</span><span class="boring">use clap::{ArgEnum, Args, Parser, Subcommand};
</span><span class="boring">
</span><span class="boring">/// Here's my app!
</span><span class="boring">#[derive(Debug, Parser)]
</span><span class="boring">#[clap(name = &quot;my-app&quot;, version)]
</span><span class="boring">pub struct App {
</span><span class="boring">    #[clap(flatten)]
</span><span class="boring">    global_opts: GlobalOpts,
</span><span class="boring">
</span><span class="boring">    #[clap(subcommand)]
</span><span class="boring">    command: Command,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Subcommand)]
</span><span class="boring">enum Command {
</span><span class="boring">    /// Help message for read.
</span><span class="boring">    Read {
</span><span class="boring">        /// An example option
</span><span class="boring">        #[clap(long, short = 'o')]
</span><span class="boring">        example_opt: bool,
</span><span class="boring">
</span><span class="boring">        /// The path to read from
</span><span class="boring">        path: Utf8PathBuf,
</span><span class="boring">        // (can #[clap(flatten)] other argument structs here)
</span><span class="boring">    },
</span><span class="boring">    /// Help message for write.
</span><span class="boring">    Write(WriteArgs),
</span><span class="boring">    // ...other commands (can #[clap(flatten)] other enum variants here)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Args)]
</span><span class="boring">struct WriteArgs {
</span><span class="boring">    /// The path to write to
</span><span class="boring">    path: Utf8PathBuf,
</span><span class="boring">    // a list of other write args
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Args)]
</span><span class="boring">struct GlobalOpts {
</span><span class="boring">    /// Color
</span><span class="boring">    #[clap(long, arg_enum, global = true, default_value_t = Color::Auto)]
</span><span class="boring">    color: Color,
</span><span class="boring">
</span><span class="boring">    /// Verbosity level (can be specified multiple times)
</span><span class="boring">    #[clap(long, short, global = true, parse(from_occurrences))]
</span><span class="boring">    verbose: usize,
</span><span class="boring">    //... other global options
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, ArgEnum)]
</span><span class="boring">enum Color {
</span><span class="boring">    Always,
</span><span class="boring">    Auto,
</span><span class="boring">    Never,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let app = App::parse();
</span><span class="boring">    println!(
</span><span class="boring">        &quot;Verbosity level specified {} times&quot;,
</span><span class="boring">        app.global_opts.verbose
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[allow(dead_code)]
</span>const EXPECTED_HELP: &amp;str = r#&quot;my-app 0.1.0
Here's my app!

USAGE:
    my-app [OPTIONS] &lt;SUBCOMMAND&gt;

OPTIONS:
        --color &lt;COLOR&gt;    Color [default: auto] [possible values: always, auto, never]
    -h, --help             Print help information
    -v, --verbose          Verbosity level (can be specified multiple times)
    -V, --version          Print version information

SUBCOMMANDS:
    help     Print this message or the help of the given subcommand(s)
    read     Help message for read
    write    Help message for write
&quot;#;
<span class="boring">
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">const EXPECTED_READ_HELP: &amp;str = r#&quot;read 
</span><span class="boring">Help message for read
</span><span class="boring">
</span><span class="boring">USAGE:
</span><span class="boring">    read [OPTIONS] &lt;PATH&gt;
</span><span class="boring">
</span><span class="boring">ARGS:
</span><span class="boring">    &lt;PATH&gt;    The path to read from
</span><span class="boring">
</span><span class="boring">OPTIONS:
</span><span class="boring">    -h, --help           Print help information
</span><span class="boring">    -o, --example-opt    An example option
</span><span class="boring">&quot;#;
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use clap::IntoApp;
</span><span class="boring">    use std::io::Cursor;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_help() {
</span><span class="boring">        let mut app = App::into_app();
</span><span class="boring">        let mut cursor: Cursor&lt;Vec&lt;u8&gt;&gt; = Cursor::new(Vec::new());
</span><span class="boring">        app.write_help(&amp;mut cursor).unwrap();
</span><span class="boring">        let help = String::from_utf8(cursor.into_inner()).unwrap();
</span><span class="boring">        println!(&quot;{}&quot;, help);
</span><span class="boring">        assert_eq!(help, EXPECTED_HELP);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_read_help() {
</span><span class="boring">        let mut app = App::into_app();
</span><span class="boring">        let mut cursor: Cursor&lt;Vec&lt;u8&gt;&gt; = Cursor::new(Vec::new());
</span><span class="boring">        let read_cmd = app.find_subcommand_mut(&quot;read&quot;).unwrap();
</span><span class="boring">        read_cmd.write_help(&amp;mut cursor).unwrap();
</span><span class="boring">        let help = String::from_utf8(cursor.into_inner()).unwrap();
</span><span class="boring">        println!(&quot;{}&quot;, help);
</span><span class="boring">        assert_eq!(help, EXPECTED_READ_HELP);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>The help for the read command is:</p>
<pre><code class="language-rust noplaypen"><span class="boring">// Run this binary with:
</span><span class="boring">//    cd code
</span><span class="boring">//    cargo run --bin grep-app -- &lt;arguments&gt;
</span><span class="boring">
</span><span class="boring">use camino::Utf8PathBuf;
</span><span class="boring">use clap::{ArgEnum, Args, Parser, Subcommand};
</span><span class="boring">
</span><span class="boring">/// Here's my app!
</span><span class="boring">#[derive(Debug, Parser)]
</span><span class="boring">#[clap(name = &quot;my-app&quot;, version)]
</span><span class="boring">pub struct App {
</span><span class="boring">    #[clap(flatten)]
</span><span class="boring">    global_opts: GlobalOpts,
</span><span class="boring">
</span><span class="boring">    #[clap(subcommand)]
</span><span class="boring">    command: Command,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Subcommand)]
</span><span class="boring">enum Command {
</span><span class="boring">    /// Help message for read.
</span><span class="boring">    Read {
</span><span class="boring">        /// An example option
</span><span class="boring">        #[clap(long, short = 'o')]
</span><span class="boring">        example_opt: bool,
</span><span class="boring">
</span><span class="boring">        /// The path to read from
</span><span class="boring">        path: Utf8PathBuf,
</span><span class="boring">        // (can #[clap(flatten)] other argument structs here)
</span><span class="boring">    },
</span><span class="boring">    /// Help message for write.
</span><span class="boring">    Write(WriteArgs),
</span><span class="boring">    // ...other commands (can #[clap(flatten)] other enum variants here)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Args)]
</span><span class="boring">struct WriteArgs {
</span><span class="boring">    /// The path to write to
</span><span class="boring">    path: Utf8PathBuf,
</span><span class="boring">    // a list of other write args
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Args)]
</span><span class="boring">struct GlobalOpts {
</span><span class="boring">    /// Color
</span><span class="boring">    #[clap(long, arg_enum, global = true, default_value_t = Color::Auto)]
</span><span class="boring">    color: Color,
</span><span class="boring">
</span><span class="boring">    /// Verbosity level (can be specified multiple times)
</span><span class="boring">    #[clap(long, short, global = true, parse(from_occurrences))]
</span><span class="boring">    verbose: usize,
</span><span class="boring">    //... other global options
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Debug, ArgEnum)]
</span><span class="boring">enum Color {
</span><span class="boring">    Always,
</span><span class="boring">    Auto,
</span><span class="boring">    Never,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let app = App::parse();
</span><span class="boring">    println!(
</span><span class="boring">        &quot;Verbosity level specified {} times&quot;,
</span><span class="boring">        app.global_opts.verbose
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">const EXPECTED_HELP: &amp;str = r#&quot;my-app 0.1.0
</span><span class="boring">Here's my app!
</span><span class="boring">
</span><span class="boring">USAGE:
</span><span class="boring">    my-app [OPTIONS] &lt;SUBCOMMAND&gt;
</span><span class="boring">
</span><span class="boring">OPTIONS:
</span><span class="boring">        --color &lt;COLOR&gt;    Color [default: auto] [possible values: always, auto, never]
</span><span class="boring">    -h, --help             Print help information
</span><span class="boring">    -v, --verbose          Verbosity level (can be specified multiple times)
</span><span class="boring">    -V, --version          Print version information
</span><span class="boring">
</span><span class="boring">SUBCOMMANDS:
</span><span class="boring">    help     Print this message or the help of the given subcommand(s)
</span><span class="boring">    read     Help message for read
</span><span class="boring">    write    Help message for write
</span><span class="boring">&quot;#;
</span><span class="boring">
</span><span class="boring">#[allow(dead_code)]
</span>const EXPECTED_READ_HELP: &amp;str = r#&quot;read 
Help message for read

USAGE:
    read [OPTIONS] &lt;PATH&gt;

ARGS:
    &lt;PATH&gt;    The path to read from

OPTIONS:
    -h, --help           Print help information
    -o, --example-opt    An example option
&quot;#;
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use clap::IntoApp;
</span><span class="boring">    use std::io::Cursor;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_help() {
</span><span class="boring">        let mut app = App::into_app();
</span><span class="boring">        let mut cursor: Cursor&lt;Vec&lt;u8&gt;&gt; = Cursor::new(Vec::new());
</span><span class="boring">        app.write_help(&amp;mut cursor).unwrap();
</span><span class="boring">        let help = String::from_utf8(cursor.into_inner()).unwrap();
</span><span class="boring">        println!(&quot;{}&quot;, help);
</span><span class="boring">        assert_eq!(help, EXPECTED_HELP);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_read_help() {
</span><span class="boring">        let mut app = App::into_app();
</span><span class="boring">        let mut cursor: Cursor&lt;Vec&lt;u8&gt;&gt; = Cursor::new(Vec::new());
</span><span class="boring">        let read_cmd = app.find_subcommand_mut(&quot;read&quot;).unwrap();
</span><span class="boring">        read_cmd.write_help(&amp;mut cursor).unwrap();
</span><span class="boring">        let help = String::from_utf8(cursor.into_inner()).unwrap();
</span><span class="boring">        println!(&quot;{}&quot;, help);
</span><span class="boring">        assert_eq!(help, EXPECTED_READ_HELP);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binaries-vs-libraries"><a class="header" href="#binaries-vs-libraries">Binaries vs libraries</a></h1>
<p>You <em>may</em> expose your application's functionality as a library. Some binaries are simple and don't necessarily need to expose their functionality as a library. Other binaries are more complex, in which case their functionality can be exposed as a library that others can build upon.</p>
<p><strong>Why separate libraries from binaries?</strong></p>
<ul>
<li>For other consumers of the library, clap and other binary-only dependencies are unnecessary.</li>
<li>The binary's versioning is separated out from the library's versioning; see <a href="versioning.html">Versioning</a> for more.</li>
</ul>
<p><strong>Reasons against exposing a library</strong></p>
<ul>
<li>Maintaining a library in addition to a binary is hard work. It involves documentation and versioning.</li>
<li>In some cases, maintainers can decide to expose their functionality <em>only</em> as a binary to force a looser coupling with downstream consumers.
<ul>
<li><em>Case study:</em> The presence of the <a href="https://libgit2.org/">libgit2</a> and <a href="https://www.eclipse.org/jgit/">JGit</a> libraries for Git has made it significantly harder to improve Git's data structures. These libraries are tightly coupled to their consumers, which in practice means that Git improvements are tied to the release schedules of commercial projects like Xcode and Visual Studio.</li>
<li>Cargo and rustc are not designed to be invoked as libraries. They force loose coupling.</li>
</ul>
</li>
</ul>
<h2 id="if-youve-decided-to-make-a-library"><a class="header" href="#if-youve-decided-to-make-a-library">If you've decided to make a library</a></h2>
<blockquote>
<p>Note: In this section, &quot;package&quot; means all code scoped to a single <code>Cargo.toml</code> file.</p>
</blockquote>
<p>If your code is meant to be uploaded to a registry like crates.io:</p>
<ul>
<li>Binary packages <em>must not</em> expose their library functionality within the same package.</li>
<li>The library package <em>must</em> be separated out, with an appropriate name linking the two.</li>
</ul>
<p>If your code is internal to the workspace:</p>
<ul>
<li>Binary packages <em>should not</em> expose a library within the same package.</li>
<li>The library package <em>should</em> be separated out, with an appropriate name linking the two.</li>
</ul>
<p>Some examples of linked names:</p>
<ul>
<li><em>my-lib</em> for the library, and <em>my-lib-cli</em> for the binary, if most people are going to use the library.</li>
<li><em>my-app-core</em> for the library, and <em>my-app</em> for the binary, if most people are going to use the binary.</li>
<li><em>my-utility</em> for the library, and <em>cargo-my-utility</em> for the binary, if your program is a Cargo plugin.</li>
</ul>
<p>There's an intermediate solution possible here, which is to have a single crate that enables being built as a binary with <code>--features=bin</code>. However, you <em>must not</em> do this for code uploaded to a registry, because you lose out on the benefits of having separate versioning. You <em>may</em> use this pattern for code internal to a workspace.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="machine-readable-output"><a class="header" href="#machine-readable-output">Machine-readable output</a></h1>
<p>Applications <em>may</em> (and in the case of forced loose coupling, <em>should</em>) make their CLI available as an interface not just to humans but to other programs. If you're making your interface available this way, follow these rules:</p>
<p><strong>For lists of strings, programs <em>should</em> provide list output as newline-delimited items.</strong></p>
<ul>
<li>This is most useful for compatibility with existing tools like <code>xargs</code>.</li>
<li>If list items are filenames or can have newlines or other in them, programs <em>must</em> provide a <code>-0</code> flag or similar to list output as null-delimited (<code>\0</code>-delimited) items. Almost all standard Unix commands understand null-delimited output (e.g. <code>xargs --null</code>).</li>
</ul>
<p><strong>For more complex structured data, programs <em>should</em> accept a flag to provide output (e.g. <code>--output-format</code>, or <code>--message-format</code> if many lines of structured data are printed out).</strong></p>
<ul>
<li>Programs <em>should</em> support at least <code>json</code> machine-readable output.</li>
<li>Programs <em>may</em> also provide their output as XML, <a href="https://cbor.io/">CBOR</a>, <a href="https://msgpack.org/index.html">MessagePack</a>, or other <strong>self-describing</strong> formats.
<ul>
<li>A self-describing format is one where the keys, or some equivalent, are part of the serialized output.</li>
</ul>
</li>
<li>Formats like <a href="https://developers.google.com/protocol-buffers">protobuf</a> are suitable as well, if up-to-date IDLs (e.g. <code>.proto</code> files) are published along with releases. One neat trick is to embed them into your binary and add a command to write them out to a given directory.</li>
<li>If many lines of structured data are incrementally printed out, prefer a format like <a href="http://ndjson.org/">newline-delimited JSON</a>. This is the format used by Cargo's <code>--message-format json</code> option.</li>
</ul>
<p><strong>Programs <em>must not</em> provide their output as <a href="https://github.com/bincode-org/bincode">bincode</a> or other non-self-describing formats.</strong> These formats are unsuitable for interoperability, where stability is paramount.</p>
<p><strong>All machine-readable output <em>must</em> be printed to stdout, <em>not</em> stderr.</strong></p>
<p><strong>Colors <em>must</em> be disabled for machine-readable output.</strong></p>
<p><strong>Within a binary version series, output <em>must</em> be kept stable and append-only.</strong> Breaking changes <em>must</em> be gated to an argument (e.g. <code>--format-version 2</code> or <code>--message-format json-v2</code>). Adding new keys to a JSON map or equivalent is generally considered stable.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="organizing-code-in-binary-crates"><a class="header" href="#organizing-code-in-binary-crates">Organizing code in binary crates</a></h1>
<p>Within a binary crate, here's the organization that's <em>recommended</em>.</p>
<p><code>my-app/src/command.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Contains command parsers and logic.

use clap::Parser;

#[derive(Debug, Parser)]
pub struct MyApp {
    // Options, subcommands etc
    #[clap(short, long, default_value_t)]
    my_arg: usize,
}

impl MyApp {
    pub fn exec(self) -&gt; color_eyre::Result&lt;()&gt; {
        println!(&quot;The value of my-arg is {}&quot;, self.my_arg);
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>my-app/src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Help text for my-app.
//!
//! Can contain information about what the binary does, command-line options,
//! configuration, etc.

mod command;
// ... other modules

// This is the only export from the crate. It is marked hidden and
// is not part of the public API.
#[doc(hidden)]
pub use command::MyApp;
<span class="boring">}
</span></code></pre></pre>
<p><code>my-app/src/bin/my-app.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">use clap::Parser;
use my_app::MyApp;

fn main() -&gt; color_eyre::Result&lt;()&gt; {
    color_eyre::install()?;

    let my_app = MyApp::parse();
    my_app.exec()
}
</code></pre></pre>
<p>Notes:</p>
<ul>
<li><strong>Most of the logic is within <code>command.rs</code>.</strong>
<ul>
<li>In general, you <em>should</em> keep lib.rs as minimal as possible, unless your entire library fits in it. That's
because all methods and fields in <code>lib.rs</code> are visible to the entire library---code in the top-level module
cannot be marked private to the rest of the module.</li>
</ul>
</li>
<li><strong>There's a <code>lib.rs</code> separate from the <code>my-app.rs</code> that contains <code>main</code>.</strong>
<ul>
<li>There are several advantages to having a <code>lib.rs</code>. In particular, <code>rustdoc</code> doesn't use standard privacy rules if building documentation from <code>main.rs</code>, so private modules are visible in the public documentation.</li>
</ul>
</li>
<li><strong>Only the top-level <code>MyApp</code> is exported.</strong>
<ul>
<li>The top-level <code>MyApp</code> is all <code>main.rs</code> should generally need to care about.</li>
</ul>
</li>
<li><strong><code>MyApp</code> is marked <code>#[doc(hidden)]</code>.</strong>
<ul>
<li>The details of <code>MyApp</code> are only meant to be seen by <code>main</code>. The library is not part of the public API. Only
the command-line interface is.</li>
</ul>
</li>
<li><strong><code>src/bin/my-app.rs</code> instead of <code>src/main.rs</code>.</strong>
<ul>
<li>While <code>src/main.rs</code> works just as well, <code>src/bin</code> makes it harder to accidentally import library code with <code>mod</code> statements.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="versioning"><a class="header" href="#versioning">Versioning</a></h1>
<p>A library crate, if provided, <em>should</em> follow <a href="https://doc.rust-lang.org/cargo/reference/semver.html">the usual Rust library versioning rules</a>.</p>
<p>A binary crate <em>should</em> define its public API as consisting of the command-line interface, plus anything else related to the interface that the project's maintainers wish to keep stable.</p>
<ul>
<li>This means that major version changes happen when there are breaking changes to the CLI, not to internal or library code.</li>
<li>For example, <a href="https://docs.rs/cargo-hakari/latest/cargo_hakari/#stability-guarantees">cargo-hakari's stability policy</a> is to keep the contents of a generated checked-in file the same, unless a config option is turned on or there's a bugfix.</li>
</ul>
<p><strong>Why?</strong> It is easier to avoid making breaking changes to command-line interfaces. Mature projects like <a href="https://www.gnu.org/software/coreutils/">GNU coreutils</a> avoid breaking changes to their CLIs for decades.</p>
<h2 id="tips-to-avoid-breaking-changes"><a class="header" href="#tips-to-avoid-breaking-changes">Tips to avoid breaking changes</a></h2>
<ul>
<li>Make experimental commands available via an environment variable or some other gating mechanism to gather feedback, with a warning that the behavior of these can change at any time.</li>
<li>Mark old commands or arguments deprecated, and possibly hide them from help text. Continue to preserve their behavior.</li>
<li>If the program persists data on disk, make it possible to do forward transitions but not backward ones. Add a <em>format version</em> to persisted data and increment it every time the data format changes. If an old version of the program reads a format version it does not understand, error out gracefully.</li>
</ul>
<blockquote>
<p>Tip: If you're using GitHub Actions for CI, use the <a href="https://github.com/baptiste0928/cargo-install">baptiste0928/cargo-install</a> action to install a binary from crates.io, using a cached version if possible. This action lets you specify a version range, which works well with the binary versioning policy above.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-colors-to-applications"><a class="header" href="#adding-colors-to-applications">Adding colors to applications</a></h1>
<p>Colors and styles can make your command-line applications look nice, and also make output easier to understand by leveraging human pattern recognition. However, adding them requires a significant amount of care.</p>
<h2 id="general-recommendations"><a class="header" href="#general-recommendations">General recommendations</a></h2>
<p>These rules apply to all command-line programs, not just Rust ones.</p>
<ol>
<li>Applications <em>should</em> have a global <code>--color</code> option, with the values <code>always</code>, <code>auto</code> (default) and <code>never</code>. If this is specified as <code>always</code> or <code>never</code>, applications <em>must</em> enable or disable colors respectively.</li>
<li>Otherwise, if one of a number of environment variables is specified, applications <em>should</em> do what it says.<sup class="footnote-reference"><a href="#color">1</a></sup></li>
<li>Otherwise, if the output stream (stdout or stderr) is a pipe, applications <em>must</em> disable colors. (Each output stream <em>must</em> be evaluated separately. For example, if stdout is a pipe but stderr isn't, applications <em>must</em> disable colors on stdout but <em>may</em> enable them on stderr.)</li>
<li>Otherwise, applications <em>may</em> enable colors.</li>
</ol>
<p>2 and 3 are covered by the <a href="https://docs.rs/supports-color/latest/supports_color/">supports-color</a> Rust library. The exact set of environment variables is too complicated to describe here. See <a href="https://docs.rs/supports-color/latest/src/supports_color/lib.rs.html">the source code of supports-color</a> for a full list.</p>
<p><strong>It <em>must</em> be possible to disable colors.</strong> Some users's terminals may have broken color support; in other cases, pipe detection may not work as expected.</p>
<div class="footnote-definition" id="color"><sup class="footnote-definition-label">1</sup>
<p>This recommendation is somewhat controversial. See <a href="https://github.com/rust-lang/rust/pull/27867">this discussion</a> in the Rust repository for more about this. I generally believe that using environment variables is OK in any output that's not designed to be machine readable.</p>
</div>
<h2 id="color-palettes"><a class="header" href="#color-palettes">Color palettes</a></h2>
<p>Terminals may support one of three color palettes:</p>
<ul>
<li><em>Truecolor (16 million colors):</em> 24-bit color; 8 bits for each of red, green and blue. This is the standard that web pages and most monitors support. You may have seen these colors written as e.g. <span style="color:#9b4fd1">#9b4fd1</span>.</li>
<li><em>256 colors:</em> 18-bit color; 6 bits for each of red, green and blue. <a href="http://www.pixelbeat.org/docs/terminal_colours/#256">This page by Pádraig Brady</a> has more information about them.</li>
<li><em>16 colors:</em> 4-bit color; black, red, green, yellow, blue, magenta, cyan, white, and a &quot;bright&quot; version of each.</li>
</ul>
<p><strong>The default color schemes in applications <em>must</em> be restricted to 12 colors: red, green, yellow, blue, magenta, cyan, and the bright versions of each of these.</strong></p>
<ul>
<li>While the wider palettes are useful for terminal theming controlled by the user, applications <em>must not</em> use them by default. The reason is that users may be using a variety of terminal themes with different backgrounds. <strong>Truecolors and 16-bit colors will not render properly with all terminal themes.</strong> For example, light-colored text will fade into a light background, or dark-colored text will fade into a dark background.</li>
<li>Most terminals allow you to configure these colors to whatever one pleases. In most themes, these 12 colors are set to contrast with the background.
<tt><span style="color: #acacab; background-color:#050505">Themes with dark backgrounds <span style="color: #a9cdeb">set &quot;blue&quot; to be lighter</span></span></tt>,
while <tt><span style="color: #0e0101; background-color:#ffffdd">themes with light backgrounds <span style="color: #3465a4">set &quot;blue&quot; to be darker</span></span></tt>. (These examples are from real themes.)</li>
<li>The &quot;black&quot; and &quot;white&quot; colors generally <em>do not</em> contrast with the background.</li>
</ul>
<p><strong>Applications <em>may</em> allow users to set their own color schemes.</strong> If users can set their own color schemes, like <a href="https://man7.org/linux/man-pages/man5/dir_colors.5.html">ls</a>, <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Colors.html">emacs</a> or <a href="https://vimhelp.org/usr_06.txt.html">vim</a> do, wider palettes of colors be supported. In these cases, users can match their color schemes with their terminal themes.</p>
<h2 id="styles"><a class="header" href="#styles">Styles</a></h2>
<p>Terminals use the same escape codes to support both colors and styles---bold, italic, etc.</p>
<p><strong>Applications <em>may</em> use bold text.</strong> Almost all terminals support <strong>bold text</strong>. Some terminals do not support <em>italic text</em> or <del>strikethroughs</del>: you can use them in your applications, but relying on them can cause issues.</p>
<p><strong>Applications <em>must not</em> use blinking text.</strong> Blinking text can be distracting or difficult to read for many people. The HTML <code>&lt;blink&gt;</code> tag, which had similar behavior, was <a href="https://www.fastcompany.com/3015408/saying-goodbye-to-the-html-tag">removed from web pages</a> around 2013.</p>
<blockquote>
<p>TODO: add information about ASCII and Unicode symbols (including emoji) that are safe to use in terminals.</p>
</blockquote>
<h2 id="ansi-color-codes-and-windows-color-apis"><a class="header" href="#ansi-color-codes-and-windows-color-apis">ANSI color codes and Windows color APIs</a></h2>
<p>Most Unix terminals support <a href="https://en.wikipedia.org/wiki/ANSI_escape_code#Colors">ANSI color codes</a>. For example, turning the foreground color to &quot;green&quot; involves writing the characters <code>\x1b</code> (ESC), <code>[</code>, <code>32</code> (for green), and <code>m</code> to the terminal.</p>
<p>Historically, Windows provided a set of <a href="https://docs.microsoft.com/en-us/windows/console/console-screen-buffers#character-attributes">Console APIs</a> for the same purpose. These APIs have <a href="https://docs.microsoft.com/en-us/windows/console/classic-vs-vt">since been deprecated</a>, and Windows now supports the same ANSI color codes other platforms do.</p>
<p><strong>Cross-platform applications <em>should not</em> target the Windows Console APIs.</strong> Instead, they should rely on the ANSI color code support built into modern Windows terminals. Note that Windows requires ANSI color code support to be initialized: the <a href="https://github.com/sunshowers/enable-ansi-support">enable-ansi-support</a> crate does that for you if you're using Rust. Call it early in <code>main</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-colors-in-rust"><a class="header" href="#managing-colors-in-rust">Managing colors in Rust</a></h1>
<p>There are many Rust libraries for managing terminal colors. You <em>should</em> use <a href="https://crates.io/crates/owo-colors">owo-colors</a> because it is the only library I've found that meets all of these criteria:</p>
<ul>
<li>actively maintained</li>
<li>has a simple, intuitive API</li>
<li>minimizes dependencies on global state</li>
<li>involves zero allocations</li>
</ul>
<blockquote>
<p>Note: you <em>should not</em> use <a href="https://docs.rs/termcolor/latest/termcolor/">termcolor</a> because it targets the deprecated Console APIs on Windows—and has a significantly more involved API as a result.</p>
<p>Instead, use a library that just only supports ANSI color codes, and initialize support for them on Windows with <a href="https://crates.io/crates/enable-ansi-support">enable-ansi-support</a>.</p>
</blockquote>
<p>There are two general ways with which color support can be handled. I'm going to call them the &quot;immediate pattern&quot; and the &quot;stylesheet approach&quot;, respectively. <strong>Library code that supports colors <em>should</em> use the stylesheet approach.</strong> Code in a binary crate can use whichever pattern leads to simpler code.</p>
<h2 id="the-immediate-pattern"><a class="header" href="#the-immediate-pattern">The immediate pattern</a></h2>
<p>This pattern is usually presented in examples and tutorials. It is conceptually quite simple.</p>
<p>Here's an example of what it looks like:</p>
<pre><code class="language-rust noplaypen"><span class="boring">#![allow(dead_code)]
</span>// The owo-colors &quot;supports-colors&quot; feature must be enabled.
use clap::{ArgEnum, Parser};
use owo_colors::{OwoColorize, Stream};

#[derive(Debug, Parser)]
struct MyApp {
    #[clap(long, arg_enum, global = true, default_value = &quot;auto&quot;)]
    color: Color,
}

#[derive(ArgEnum, Clone, Copy, Debug)]
enum Color {
    Always,
    Auto,
    Never,
}

impl Color {
    fn init(self) {
        // Set a supports-color override based on the variable passed in.
        match self {
            Color::Always =&gt; owo_colors::set_override(true),
            Color::Auto =&gt; {}
            Color::Never =&gt; owo_colors::set_override(false),
        }
    }
}

fn main() {
    let app = MyApp::parse();
    app.color.init();

    println!(
        &quot;My number is {}&quot;,
        42.if_supports_color(Stream::Stdout, |text| text.bright_blue())
    );
}
</code></pre>
<p>Notes:</p>
<ul>
<li><strong><code>owo_colors::set_override</code> is used to control color support globally.</strong> The global configuration only has an effect if <code>if_supports_color</code> is called.</li>
<li><strong><code>println!</code> is paired with <code>Stream::Stdout</code>.</strong> If this were <code>eprintln!</code>, it would need to be paired with <code>Stream::Stderr</code>.</li>
</ul>
<p>While this pattern is sometimes convenient in binary code, <strong>it <em>should not</em> be used in libraries.</strong> That is because libraries <em>should not</em> print information directly out to stdout or stderr—instead, they should return values that implement <code>Display</code> or similar. Library code <em>should</em> use the stylesheet approach instead.</p>
<h2 id="the-stylesheet-approach"><a class="header" href="#the-stylesheet-approach">The stylesheet approach</a></h2>
<p>This pattern involves defining a <code>Styles</code> struct containing colors and styles to apply to a text.</p>
<p>A stylesheet is simply a list of dynamic styles, customized to a particular type to be displayed. Here's an example:</p>
<pre><code class="language-rust noplaypen"><span class="boring">use std::fmt;
</span>use owo_colors::{OwoColorize, Style};

// Stylesheet used to colorize MyValueDisplay below.
#[derive(Debug, Default)]
struct Styles {
    number_style: Style,
    shape_style: Style,
    // ... other styles
}

impl Styles {
    fn colorize(&amp;mut self) {
        self.number_style = Style::new().bright_blue();
        self.shape_style = Style::new().bright_green();
        // ... other styles
    }
}
<span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">pub struct MyValue {
</span><span class="boring">    number: usize,
</span><span class="boring">    shape: &amp;'static str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl MyValue {
</span><span class="boring">    pub fn new(number: usize, shape: &amp;'static str) -&gt; Self {
</span><span class="boring">        Self { number, shape }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Returns a type that can display `MyValue`.
</span><span class="boring">    pub fn display(&amp;self) -&gt; MyValueDisplay&lt;'_&gt; {
</span><span class="boring">        MyValueDisplay {
</span><span class="boring">            value: self,
</span><span class="boring">            styles: Box::new(Styles::default()),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Displayer for [`MyValue`].
</span><span class="boring">pub struct MyValueDisplay&lt;'a&gt; {
</span><span class="boring">    value: &amp;'a MyValue,
</span><span class="boring">    styles: Box&lt;Styles&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; MyValueDisplay&lt;'a&gt; {
</span><span class="boring">    /// Colorizes the output.
</span><span class="boring">    pub fn colorize(&amp;mut self) {
</span><span class="boring">        self.styles.colorize();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; fmt::Display for MyValueDisplay&lt;'a&gt; {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
</span><span class="boring">        write!(
</span><span class="boring">            f,
</span><span class="boring">            &quot;My number is {}, and my shape is a {}&quot;,
</span><span class="boring">            self.value.number.style(self.styles.number_style),
</span><span class="boring">            self.value.shape.style(self.styles.shape_style),
</span><span class="boring">        )
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Here's some library code that uses the above stylesheet:</p>
<pre><code class="language-rust noplaypen"><span class="boring">use std::fmt;
</span><span class="boring">use owo_colors::{OwoColorize, Style};
</span><span class="boring">
</span><span class="boring">// Stylesheet used to colorize MyValueDisplay below.
</span><span class="boring">#[derive(Debug, Default)]
</span><span class="boring">struct Styles {
</span><span class="boring">    number_style: Style,
</span><span class="boring">    shape_style: Style,
</span><span class="boring">    // ... other styles
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Styles {
</span><span class="boring">    fn colorize(&amp;mut self) {
</span><span class="boring">        self.number_style = Style::new().bright_blue();
</span><span class="boring">        self.shape_style = Style::new().bright_green();
</span><span class="boring">        // ... other styles
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Debug)]
pub struct MyValue {
    number: usize,
    shape: &amp;'static str,
}

impl MyValue {
    pub fn new(number: usize, shape: &amp;'static str) -&gt; Self {
        Self { number, shape }
    }

    /// Returns a type that can display `MyValue`.
    pub fn display(&amp;self) -&gt; MyValueDisplay&lt;'_&gt; {
        MyValueDisplay {
            value: self,
            styles: Box::new(Styles::default()),
        }
    }
}

/// Displayer for [`MyValue`].
pub struct MyValueDisplay&lt;'a&gt; {
    value: &amp;'a MyValue,
    styles: Box&lt;Styles&gt;,
}

impl&lt;'a&gt; MyValueDisplay&lt;'a&gt; {
    /// Colorizes the output.
    pub fn colorize(&amp;mut self) {
        self.styles.colorize();
    }
}

impl&lt;'a&gt; fmt::Display for MyValueDisplay&lt;'a&gt; {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(
            f,
            &quot;My number is {}, and my shape is a {}&quot;,
            self.value.number.style(self.styles.number_style),
            self.value.shape.style(self.styles.shape_style),
        )
    }
}
</code></pre>
<p>And finally, here's the binary code that uses the library.</p>
<pre><code class="language-rust noplaypen"><span class="boring">#![allow(dead_code)]
</span><span class="boring">use clap::{ArgEnum, Parser};
</span><span class="boring">use my_app::MyValue;
</span><span class="boring">use owo_colors::Stream;
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Parser)]
</span><span class="boring">struct MyApp {
</span><span class="boring">    #[clap(long, arg_enum, global = true, default_value = &quot;auto&quot;)]
</span><span class="boring">    color: Color,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(ArgEnum, Clone, Copy, Debug)]
</span><span class="boring">enum Color {
</span><span class="boring">    Always,
</span><span class="boring">    Auto,
</span><span class="boring">    Never,
</span><span class="boring">}
</span><span class="boring">
</span>// This example uses the supports-color crate:
// https://crates.io/crates/supports-color
//
// MyApp and Color definitions are repeated from the &quot;immediate pattern&quot;
// example above.

impl Color {
    fn supports_color_on(self, stream: Stream) -&gt; bool {
        match self {
            Color::Always =&gt; true,
            Color::Auto =&gt; supports_color::on_cached(stream).is_some(),
            Color::Never =&gt; false,
        }
    }
}

fn main() {
    let app = MyApp::parse();

    let my_value = MyValue::new(24, &quot;circle&quot;);
    let mut display = my_value.display();
    if app.color.supports_color_on(Stream::Stdout) {
        display.colorize();
    }
    println!(&quot;{}&quot;, display);
}
</code></pre>
<p>Notes:</p>
<ul>
<li><strong>Library code is completely unaware of whether the environment supports colors.</strong> All it cares about is whether the <code>colorize</code> method is called.
<ul>
<li>Note that the global <code>set_override</code> and <code>unset_override</code> methods have no impact on library code in the stylesheet example.</li>
<li>The global methods are only active if <code>if_supports_color</code> is called, as shown by the example for <a href="managing-colors-in-rust.html#the-immediate-pattern">the immediate pattern</a> above. This is by design: most libraries shouldn't reach out to global state.</li>
</ul>
</li>
<li><strong>The stylesheet is stored as <code>Box&lt;Styles&gt;</code>.</strong> The boxing isn't strictly required, but each <code>Style</code> is pretty large, and a struct containing e.g. 16 styles is 272 bytes as of owo-colors 3.2.0. That's a pretty large amount of data to store on the stack.</li>
<li><strong><code>Styles::default()</code> initializes all the styles to having no effect.</strong> The <code>colorize()</code> method then initializes them as required.</li>
<li><strong>For custom color support, <code>Styles</code> can be made public.</strong> Most library code won't need to give users the ability to customize styles, but this pattern naturally extends to that use case.</li>
<li><strong>Use of a separate <code>MyAppDisplay</code> type.</strong> The <code>colorize</code> call is isolated to this particular <code>MyAppDisplay</code>, without influencing other display calls.</li>
<li><strong><code>println!</code> is paired with <code>Stream::Stdout</code>.</strong> If this were <code>eprintln!</code>, it would need to be paired with <code>Stream::Stderr</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>Simple applications are able to accept all their options over the command line, but more complex ones eventually need to add support for configuration files.</p>
<h2 id="configuration-formats"><a class="header" href="#configuration-formats">Configuration formats</a></h2>
<p><strong>Configuration <em>should</em> be in the <a href="https://toml.io/en/">TOML format</a>.</strong> The TOML format, as a descendant of INI, is widely understood and is easy to read and write for both humans and computers.</p>
<p><a href="https://yaml.org/">YAML</a> <em>may</em> be used if the configuration is complex enough (though in these cases it's often fruitful to devise ways of reducing complexity), or if there are legacy constraints.</p>
<p>Some utilities require more expressive power in their configuration; for example, <a href="https://wezfurlong.org/wezterm/">wezterm</a> uses <a href="https://wezfurlong.org/wezterm/config/files.html">Lua</a>, while <a href="https://bazel.build/">Bazel</a> uses a custom configuration language inspired by Python called <a href="https://docs.bazel.build/versions/main/skylark/language.html">Starlark</a>.</p>
<h2 id="configuration-scopes"><a class="header" href="#configuration-scopes">Configuration scopes</a></h2>
<p>Depending on the application, the following scopes for a configuration are often seen in practice:</p>
<ol>
<li><em>Directory-scoped.</em> Applies to a directory and its subdirectories. Controlled by a file somewhere in this directory or a parent. For example, <a href="https://git-scm.com/docs/gitignore"><code>.gitignore</code></a> is directory-scoped.</li>
<li><em>Repository-scoped.</em> Applies to a repository: controlled by a file somewhere in a code repository. For example, <a href="https://github.com/rust-lang/rust-clippy#configuration"><code>clippy.toml</code></a> is repository-scoped.</li>
<li><em>User-scoped.</em> A file somewhere in the user's home directory.</li>
<li><em>System-wide.</em> A file somewhere in a central location on the computer.</li>
</ol>
<p>Not all applications support all of these: which scopes make sense is a matter of judgment and thinking about use cases. Some server-side applications support fetching configuration from a remote server; they are out of scope here.</p>
<p><strong>If applications support repository-scoped configuration:</strong></p>
<ul>
<li>Applications <em>should</em> put repository-scoped configuration in a <code>.config</code> directory under the repository root. Typically, applications place their configuration at the top level of the repository. However, too many config files at the top level can pollute directory listings.</li>
<li>Applications <em>should</em> allow both local and checked-in configuration files. For example, an application <code>myapp</code> should support configuration in both <code>.config/myapp.toml</code> and <code>.config/myapp.local.toml</code>. Entries in <code>./config/myapp.local.toml</code> <em>must</em> override those in <code>.config/myapp.toml</code>.</li>
</ul>
<p><strong>If applications support user-scoped configuration:</strong></p>
<ul>
<li>On Unix platforms other than macOS, applications <em>should</em> follow the <a href="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html">XDG specification</a>.</li>
<li>On macOS and Windows, applications <em>should</em> either use <code>$HOME/.config</code> or the platform-native config directory. On macOS and Windows, the platform-native directories are somewhat harder to access on the command line, so <code>$HOME/.config</code> is a suitable alternative.</li>
</ul>
<p><a href="https://crates.io/crates/dirs">dirs</a> is the most actively maintained Rust library for getting the native config directory (and other directories) for every platform.</p>
<p><strong>Applications <em>may</em> read configuration options over the command line and the environment.</strong> It is often reasonable to let users override configuration via command-line options and environment variables. If so, then:</p>
<ul>
<li>Environment variables <em>must</em> be prefixed with a unique identifier based on the app. For example, an app called <code>myapp</code> can support a &quot;limit&quot; configuration through a <code>MYAPP_LIMIT</code> variable.</li>
<li>Environment variables <em>should</em> also be supported as command-line options. For example, <code>myapp --limit</code>. Command-line options are more discoverable than environment variables. If you actually <em>want</em> your options to be less discoverable, for example if exposing them would increase support load, you can add hidden command-line options.</li>
<li>Command-line arguments <em>must</em> override environment variables. An environment variable can be set further up in the environment. A command-line argument expresses user intent most directly.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hierarchical-configuration"><a class="header" href="#hierarchical-configuration">Hierarchical configuration</a></h1>
<p><strong>Applications <em>should</em> follow a hierarchical configuration structure.</strong> Use the following order, from highest priority to lowest.</p>
<ol>
<li>Command-line arguments</li>
<li>Environment variables</li>
<li>Directory or repository-scoped configuration</li>
<li>User-scoped configuration</li>
<li>System-wide configuration</li>
<li>Default configuration shipped with the program.</li>
</ol>
<p>There are some exceptions. For example, color support <em>should</em> follow the rules listed in the <a href="./colors.html">Colors</a> section.</p>
<p><strong>Configurations <em>may</em> be merged rather than completely overwritten.</strong> Consider the following configuration files.</p>
<pre><code class="language-toml"># $HOME/.config/myapp.toml -- user-scoped config
limit = 42

[encoding]
input = &quot;utf16&quot;
output = &quot;latin1&quot;
</code></pre>
<pre><code class="language-toml"># &lt;repository&gt;/.config/myapp.toml -- repository-scoped config
limit = 84

[encoding]
input = &quot;utf8&quot;
</code></pre>
<p>One way to merge configurations is to combine them, as follows:</p>
<pre><code class="language-toml">limit = 84

[encoding]
input = &quot;utf8&quot;
output = &quot;latin1&quot;
</code></pre>
<p>Exactly how deep merges should go is application-specific.</p>
<h2 id="rust-libraries-for-managing-configuration"><a class="header" href="#rust-libraries-for-managing-configuration">Rust libraries for managing configuration</a></h2>
<p>There are two main Rust libraries for managing hierarchical configuration:</p>
<ul>
<li><a href="https://crates.io/crates/config">config</a>. I've used this for my own projects.</li>
<li><a href="https://crates.io/crates/figment">figment</a>. Seems high quality, though I haven't used it.</li>
</ul>
<p>These configuration libraries can be used in combination with serde, so that you can manage hierarchies and merges with dynamically typed variables at the edges of your program, then switch over to well-typed serde structures for validating the config's schema. For how to do this with config, <a href="https://github.com/mehcode/config-rs/blob/53e43fbcf96b5c2a661d052a6e3d55fc3709f1e1/examples/hierarchical-env/settings.rs">see this example</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-words"><a class="header" href="#key-words">Key words</a></h1>
<p>The key words <em>must</em>, <em>must not</em>, <em>required</em>, <em>should</em>, <em>should not</em>,
<em>recommended</em>, <em>may</em>, and <em>optional</em>, derive their meanings from
<a href="https://datatracker.ietf.org/doc/html/rfc2119">RFC 2119</a>, but have
somewhat different connotations because this is a list of recommendations
and not a standard.</p>
<ul>
<li><em>must</em>, <em>must not</em> and <em>required</em> mean that an application that doesn't follow this recommendation is <em>incorrect</em> and has a bug that needs to be fixed.</li>
<li><em>should</em>, <em>should not</em> and <em>recommended</em> mean that most applications should follow this recommendation, but there are valid reasons not to.</li>
<li><em>may</em> and <em>optional</em> mean that programs are free to follow this recommendation or ignore it; there are valid reasons in either direction.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acknowledgments"><a class="header" href="#acknowledgments">Acknowledgments</a></h1>
<p>Thanks to the following reviewers who read through drafts of this document and provided invaluable feedback:</p>
<ul>
<li>Ana Hobden (<a href="https://twitter.com/a_hoverbear">Twitter</a>, <a href="https://github.com/hoverbear">GitHub</a>)</li>
<li>Brandon Williams (<a href="https://twitter.com/bmwill_">Twitter</a>, <a href="https://github.com/bmwill">GitHub</a>)</li>
<li>Ed Page (<a href="https://github.com/epage">GitHub</a>)</li>
<li>Inanna Malick (<a href="https://twitter.com/inanna_malick/">Twitter</a>, <a href="https://github.com/inanna-malick">GitHub</a>)</li>
<li>jam1garner (<a href="https://twitter.com/jam1garner">Twitter</a>, <a href="https://github.com/jam1garner">GitHub</a>)</li>
<li>Jane Lusby (<a href="https://twitter.com/yaahc_">Twitter</a>, <a href="https://github.com/yaahc">GitHub</a>)</li>
<li>Manish Goregaokar (<a href="https://twitter.com/ManishEarth">Twitter</a>, <a href="https://github.com/Manishearth">GitHub</a>)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<p><strong>2022-01-21:</strong> Initial public version.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
