<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rain&#x27;s Rust CLI recommendations</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="ch01-00-introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-why-listen.html"><strong aria-hidden="true">1.1.</strong> Why listen to me?</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-picking.html"><strong aria-hidden="true">2.</strong> Picking a command-line argument parser</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-handling-arguments.html"><strong aria-hidden="true">2.1.</strong> Handling arguments and subcommands</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-binaries-vs-libraries.html"><strong aria-hidden="true">3.</strong> Binaries vs libraries</a></li><li class="chapter-item expanded "><a href="ch04-00-versioning.html"><strong aria-hidden="true">4.</strong> Versioning</a></li><li class="chapter-item expanded "><a href="ch05-00-configuration.html"><strong aria-hidden="true">5.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="ch06-00-colors.html"><strong aria-hidden="true">6.</strong> Adding colors to applications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-managing-colors-in-rust.html"><strong aria-hidden="true">6.1.</strong> Managing colors in Rust</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rain&#x27;s Rust CLI recommendations</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book covers <a href="https://github.com/sunshowers">Rain's</a> opinions about how to organize and manage Rust CLI applications.</p>
<p>The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;,
&quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;,  &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this document are to be
interpreted as described in <a href="https://datatracker.ietf.org/doc/html/rfc2119">RFC 2119</a>.</p>
<p>Issues containing recommendations and PRs are welcome! However, I get to make the final call: if your opinions diverge from mine, you're welcome to fork this project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-listen-to-me"><a class="header" href="#why-listen-to-me">Why listen to me?</a></h1>
<p>I'm a reasonably proficient Rust developer, and have been using Rust professionally full-time since early 2017. I've also released the open source Rust CLI tools <a href="https://crates.io/crates/cargo-hakari">cargo-hakari</a> and <a href="https://crates.io/crates/cargo-search2">cargo-search2</a>, with more in development.</p>
<p>The list of recommendations is based on what I personally value most; however, most of these involve tradeoffs along a <a href="https://en.wikipedia.org/wiki/Pareto_efficiency">Pareto front</a>. Wherever possible, I provide a list of benefits and costs, and alternatives, to help you make an informed decision.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="picking-a-command-line-argument-parser"><a class="header" href="#picking-a-command-line-argument-parser">Picking a command-line argument parser</a></h1>
<p>There are a number of different command-line parsers for Rust programs. However, projects SHOULD use <a href="https://crates.io/crates/clap"><strong>clap</strong></a>.</p>
<p><strong>Why?</strong></p>
<ul>
<li>clap is actively maintained: as of January 2022, clap just came out with a <a href="">v3 release</a>.</li>
<li>clap is the most popular command-line parsing library for Rust, which means that there's an existing ecosystem of projects around clap.</li>
<li>clap comes with a number of extra features, such as suggestions based on <a href="https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance">Jaro–Winkler distance</a> and full configurability of <a href="https://docs.rs/clap/latest/clap/enum.AppSettings.html">commands</a> and <a href="https://docs.rs/clap/latest/clap/enum.ArgSettings.html">arguments</a></li>
<li>There are a number of standard conventions for Unix CLIs: see <a href="https://github.com/google/argh/issues/3#issuecomment-581144181">this comment</a> by <a href="https://github.com/ssokolow">Stephen Sokolow</a>. Another actively maintained project, <a href="https://github.com/google/argh">argh</a>, does not target Unix platforms and so does not support all of these conventions.</li>
</ul>
<p><strong>Why not?</strong></p>
<ul>
<li>clap pulls in several dependencies and takes quite a while to build.</li>
<li>clap increases binary size significantly.</li>
<li>clap is a complex parser with many different options, which can be overwhelming. I've found use for many of these options.</li>
<li>The latest version of clap as of January 2022 is 3.0.6. This version currently has a Minimum Supported Rust Version (MSRV) of Rust 1.54; I personally do not consider this to be a negative but there's <a href="https://github.com/clap-rs/clap/issues/3267">some discussions about it</a>. For now, a workaround is to use clap v2.</li>
</ul>
<h2 id="automatically-deriving-fields"><a class="header" href="#automatically-deriving-fields">Automatically deriving fields</a></h2>
<p>Projects MAY turn on the <code>derive</code> feature in clap and use a declarative model to define command-line arguments. (The <code>derive</code> feature is new to v3---users of clap v2 can use <a href="https://crates.io/crates/structopt">structopt</a>, which <code>clap_derive</code> is based on.)</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use clap::Parser;

/// A very simple utility to search for a string across multiple files.
#[derive(Debug, Parser)]
pub struct GrepApp {
    /// Suppress normal output; instead print the name of each input file from which output
    /// would normally have been printed.  Scanning each input file stops upon first match.
    #[clap(long, short = &quot;l&quot;)]
    files_with_matches: bool,

    /// Search string
    search_str: String,

    /// Input files
    files: Vec&lt;String&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>The doc comments are processed as help text by clap.</p>
<p><strong>Why?</strong></p>
<ul>
<li>Derive-style arguments are significantly easier to read, write, and modify.</li>
<li>Derive-style components can be written once, and reused across multiple commands.</li>
</ul>
<p><strong>Why not?</strong></p>
<ul>
<li>The derive macro is an optional feature that pulls in extra dependencies and increase build times.</li>
<li>The derive macro can be a bit magical. Looking at <a href="https://github.com/clap-rs/clap/blob/master/clap_derive/src/lib.rs">the source code of clap_derive</a> may be useful sometimes.</li>
</ul>
<h2 id="alternatives-to-clap"><a class="header" href="#alternatives-to-clap">Alternatives to clap</a></h2>
<ul>
<li><a href="https://github.com/google/argh">argh</a>: Google's argument parser. Actively maintained, but targets the Fuchsia OS rather than Unix platforms, so missing several crucial features.</li>
<li><a href="https://github.com/RazrFalcon/pico-args">pico-args</a>: Quick to compile and negligible impact on binary size, but does not include help generation, derive support, or as many config flags as clap.</li>
<li><a href="https://crates.io/crates/gumdrop">gumdrop</a>: a simple argument parser with derive support. Somewhat less popular than clap, and doesn't support deserializing directly to domain types (clap <a href="https://github.com/clap-rs/clap/blob/v3.0.6/examples/derive_ref/README.md#arg-types">does</a>).</li>
<li>Writing your own by hand: applications SHOULD NOT do this. You're probably going to get it wrong and annoy people---but it's an option if you must.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-arguments-and-subcommands"><a class="header" href="#handling-arguments-and-subcommands">Handling arguments and subcommands</a></h1>
<p>For a program that has subcommands, the following code structure is RECOMMENDED.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use clap::{ArgEnum, Parser};

/// Help message for the app.
#[derive(Debug, Parser)]
pub struct App {
    #[clap(flatten)]
    global_opts: GlobalOpts,

    #[clap(subcommand)]
    command: Command,
}

#[derive(Debug, Parser)]
enum Command {
    /// Help message for read.
    Read {
        #[clap(long, short)]
        opt: bool,

        path: PathBuf,
        // consider using camino's Utf8PathBuf instead:
        // https://docs.rs/camino/latest/camino/struct.Utf8PathBuf.html
    },
    /// Help message for write.
    Write {
        #[clap(flatten)]
        write_args: WriteArgs,
    }
}

#[derive(Debug, Parser)]
struct WriteArgs {
    path: PathBuf,
    // a list of other write args
}

#[derive(Debug, Parser)]
struct GlobalOpts {
    #[clap(long, arg_enum, global = true, default_value_t = Color::Auto)]
    color: Color,
    // ... other global options like -q/--quiet or -v/--verbose
}

#[derive(Clone, Debug, ArgEnum)]
enum Color {
    Always,
    Auto,
    Never,
}
<span class="boring">}
</span></code></pre></pre>
<p>Notes:</p>
<ul>
<li><strong>Only the top-level <code>App</code> is public.</strong></li>
<li><strong><code>App</code> is a struct, one level above the command enum.</strong>
<ul>
<li>While it is possible to make <code>App</code> an enum with all the subcommands, in my experience this design has always come back to bite me. This has always been because I've wanted to introduce global options later.</li>
</ul>
</li>
<li><strong>Liberal use of <code>#[clap(flatten)]</code>.</strong>
<ul>
<li>This helps break up arguments into smaller components that can be more easily processed in different sections of the project's code. For example, <code>Color</code> can be further nested into an <code>OutputOpts</code> struct, defined in a separate <code>output.rs</code> file.</li>
<li>It also helps code pass a complex set of arguments around as a single parameter, rather than having to add a parameter everywhere.</li>
</ul>
</li>
<li><strong>Global options are marked with <code>#[clap(global = true)]</code>.</strong>
<ul>
<li>This means that global options like <code>--color</code> can be used anywhere in the command line.</li>
</ul>
</li>
<li><strong>Use of <code>ArgEnum</code>.</strong>
<ul>
<li><code>ArgEnum</code> simplifies the definition of arguments that take one of a limited number of values.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binaries-vs-libraries"><a class="header" href="#binaries-vs-libraries">Binaries vs libraries</a></h1>
<p>Binaries MAY expose their functionality as a library as well.</p>
<p><strong>Why?</strong>
Some binaries are simple and don't necessarily need to expose their functionality as a library. Other binaries are more complex, in which case they may wish to expose their functionality as a library so that others may build upon it.</p>
<p>In any case, binary <em>crates</em> SHOULD NOT expose their library functionality within the same crate. The library, if exposed, SHOULD be a different crate, with an appropriate name linking the two. The library SHOULD NOT have any command-line parsing logic.</p>
<p><strong>Why?</strong></p>
<ul>
<li>For other consumers of the library, clap may be an unnecessary dependency.</li>
<li>The binary's versioning is separated out from the library's versioning; see <a href="ch04-00-versioning.html">Versioning</a> for more.</li>
<li>Compile times become quicker.</li>
</ul>
<p><strong>Why not?</strong></p>
<ul>
<li>Maintaining a library in addition to a binary is hard work.</li>
<li>In some cases, maintainers may decide to expose their functionality <em>only</em> as a binary to force a looser coupling with downstream consumers.
<ul>
<li>For example, the presence of the <a href="https://libgit2.org/">libgit2</a> and <a href="https://www.eclipse.org/jgit/">JGit</a> libraries for Git has made it significantly harder to improve Git's data structures. These libraries are tightly coupled to their consumers, which in practice means that Git improvements are tied to the release schedules of commercial projects like Xcode and Visual Studio. Forced loose coupling can lead to greater development velocity.</li>
</ul>
</li>
</ul>
<h2 id="providing-an-ipc-interface"><a class="header" href="#providing-an-ipc-interface">Providing an IPC interface</a></h2>
<p>Programs MAY (and in the case of forced loose coupling, SHOULD) make their CLI available as an interface not just to humans but to other programs. In these cases, follow these rules:</p>
<ul>
<li>Programs SHOULD accept a <code>--message-format</code> flag, and SHOULD support at least <code>json</code> for programmatic consumption.</li>
<li>Programs MAY also provide their output as other formats like XML, <a href="https://cbor.io/">CBOR</a>, <a href="https://msgpack.org/index.html">MessagePack</a>, or other <strong>self-describing</strong> formats.
<ul>
<li>A self-describing format is one where the keys, or some equivalent, are part of the serialized output.</li>
<li>Formats like <a href="https://developers.google.com/protocol-buffers">protobuf</a> are suitable as well, if up-to-date IDLs (e.g. <code>.proto</code> files) are published along with releases. One neat trick is to embed them into your binary and add a command to write them out to a given directory.</li>
</ul>
</li>
<li>Programs MUST NOT provide their output as <a href="https://github.com/bincode-org/bincode">bincode</a> or other non-self-describing formats. These formats are unsuitable for inter-process communication.</li>
<li>For greater compatibility with existing Unix tools like <code>xargs</code>, programs MAY provide list output as newline-delimited items.
<ul>
<li>If list items that may themselves have newlines in them, programs MUST provide list output as null-delimited (<code>\0</code>-delimited) items. In particular, filenames may have newlines embedded in them but not null bytes. Almost all standard Unix commands understand NULL-delimited output (e.g. <code>xargs --null</code>).</li>
</ul>
</li>
<li>Color MUST be disabled while writing to a pipe, unless <code>--color=always</code> is passed in.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="versioning"><a class="header" href="#versioning">Versioning</a></h1>
<p>A library crate, if provided, SHOULD follow <a href="https://doc.rust-lang.org/cargo/reference/semver.html">the usual Rust library versioning rules</a>.</p>
<p>A binary crate SHOULD NOT follow those rules. Instead, the public API SHOULD consist of the command-line interface, plus anything else related to the interface that the project's maintainers wish to keep stable.</p>
<ul>
<li>This means that there should only be a major version change when there's a breaking change to the CLI.</li>
<li>For example, <a href="https://docs.rs/cargo-hakari/latest/cargo_hakari/#stability-guarantees">cargo-hakari's stability policy</a> is to keep the contents of a generated checked-in file the same, unless a config option is turned on or there's a bugfix.</li>
</ul>
<p><strong>Why?</strong> It is easier to avoid making breaking changes to command-line interfaces. Mature projects like <a href="https://www.gnu.org/software/coreutils/">GNU coreutils</a> avoid breaking changes to their CLIs for decades.</p>
<h2 id="tips-for-avoiding-breaking-changes"><a class="header" href="#tips-for-avoiding-breaking-changes">Tips for avoiding breaking changes</a></h2>
<ul>
<li>Make experimental commands available via an environment variable or some other gating mechanism to gather feedback, with a warning that the behavior of these can change at any time.</li>
<li>Mark old commands or arguments deprecated, and possibly hide them from help text. Continue to preserve their behavior.</li>
<li>If the program persists data on disk, make it possible to do forward transitions but not backward ones. Add a <em>format version</em> to persisted data and increment it every time the data format changes. If an old version of the program reads a format version it does not understand, error out gracefully.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-colors-to-applications"><a class="header" href="#adding-colors-to-applications">Adding colors to applications</a></h1>
<p>Colors can make your command-line applications look nice, and also make output easier to understand by leveraging human pattern recognition. However, adding them requires a significant amount of care.</p>
<h2 id="general-recommendations"><a class="header" href="#general-recommendations">General recommendations</a></h2>
<p>These rules apply to all command-line programs, not just Rust ones.</p>
<p><strong>Applications SHOULD follow this pattern:</strong></p>
<ol>
<li>A global <code>--color</code> option, with the values <code>always</code>, <code>auto</code> (default) and <code>never</code>. If this is specified as <code>always</code> or <code>never</code>, enable or disable colors respectively.</li>
<li>Otherwise, if one of a number of environment variables is specified, use what it says.</li>
<li>Otherwise, if the output stream (stdout or stderr) is a terminal (also called a &quot;tty&quot;), and the enable colors. Otherwise, disable them.</li>
</ol>
<p>2 and 3 are covered by the <a href="https://docs.rs/supports-color/latest/supports_color/">supports-color</a> Rust library. The exact set of environment variables is too complicated to describe here. See <a href="https://docs.rs/supports-color/latest/src/supports_color/lib.rs.html">the source code of supports-color</a> for a full list.</p>
<p><strong>It MUST be possible to disable colors.</strong> Some users's terminals may have broken color support; in some cases, pipe detection may not work as expected.</p>
<p>Terminals may support one of three color palettes:</p>
<ul>
<li>Truecolor: 16 million colors (24-bit color; 8 bits for each of red, green and blue). This is the standard that web pages and most monitors support. You may have seen these colors written as e.g. <span style="color:#9b4fd1">#9b4fd1</span>.</li>
<li>256 colors: 18-bit color; 6 bits for each of red, green and blue. <a href="http://www.pixelbeat.org/docs/terminal_colours/#256">This page by Pádraig Brady</a> has more information about them.</li>
<li>16 colors: black, red, green, yellow, blue, magenta, cyan, white, and a &quot;bright&quot; version of each.</li>
</ul>
<p><strong>The default color schemes in applications SHOULD restrict themselves to red, green, yellow, blue, magenta, cyan, and the bright versions of each of these.</strong></p>
<ul>
<li>While the wider palettes are useful for terminal theming controlled by the user, applications SHOULD NOT use it. The reason is that users may be using a variety of terminal themes with different backgrounds. <strong>Truecolors and 16-bit colors will not render properly with all terminal themes.</strong> For example, light-colored text will fade into a light background, or dark-colored text will fade into a dark background.</li>
<li>Most terminals allow you to configure <em>just</em> these colors to whatever one pleases. In most themes, these 12 colors are set to contrast with the background. For example, themes with dark backgrounds set &quot;green&quot; to be lighter, while themes with light backgrounds would set &quot;green&quot; to be darker.</li>
<li>The &quot;black&quot; and &quot;white&quot; colors generally <em>do not</em> contrast with the background.</li>
</ul>
<p><strong>Applications MAY allow users to set their own color schemes.</strong> If users can set their own color schemes, like <a href="https://man7.org/linux/man-pages/man5/dir_colors.5.html">ls</a>, <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Colors.html">emacs</a> or <a href="https://vimhelp.org/usr_06.txt.html">vim</a> do, a wider range of colors can be supported. In these cases, users can match their color schemes with their terminal themes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-colors-in-rust"><a class="header" href="#managing-colors-in-rust">Managing colors in Rust</a></h1>
<p>TODO</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
