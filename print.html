<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rain&#x27;s Rust CLI recommendations</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Covers recommendations for writing and structuring Rust command-line programs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html">Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="why-listen.html">Why listen to me?</a></li></ol></li><li class="chapter-item expanded "><a href="cli-parser.html">Picking a command-line argument parser</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="handling-arguments.html">Handling arguments and subcommands</a></li></ol></li><li class="chapter-item expanded "><a href="binaries-vs-libraries.html">Binaries vs libraries</a></li><li class="chapter-item expanded "><a href="versioning.html">Versioning</a></li><li class="chapter-item expanded "><a href="configuration.html">Configuration</a></li><li class="chapter-item expanded "><a href="colors.html">Adding colors to applications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="managing-colors-in-rust.html">Managing colors in Rust</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="contributors.html">Contributors</a></li><li class="chapter-item expanded affix "><a href="changelog.html">Changelog</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rain&#x27;s Rust CLI recommendations</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sunshowers-code/rust-cli-recommendations" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rains-rust-cli-recommendations"><a class="header" href="#rains-rust-cli-recommendations">Rain's Rust CLI recommendations</a></h1>
<p>This living document covers <a href="https://github.com/sunshowers">Rain's</a> opinions about how to organize and manage Rust CLI applications.</p>
<h2 id="key-words"><a class="header" href="#key-words">Key words</a></h2>
<p>The key words <em>must</em>, <em>must not</em>, <em>required</em>, <em>should</em>, <em>should not</em>,
<em>recommended</em>, <em>may</em>, and <em>optional</em>, derive their meanings from
<a href="https://datatracker.ietf.org/doc/html/rfc2119">RFC 2119</a>, but have
somewhat different connotations because this is a list of recommendations
and not a standard.</p>
<ul>
<li><em>must</em>, <em>must not</em> and <em>required</em> mean that an application that doesn't follow this recommendation is <em>incorrect</em> and has a bug that needs to be fixed.</li>
<li><em>should</em>, <em>should not</em> and <em>recommended</em> mean that most applications should follow this recommendation, but there are valid reasons not to.</li>
<li><em>may</em> and <em>optional</em> mean that programs are free to follow this recommendation or ignore it; there are valid reasons in either direction.</li>
</ul>
<h2 id="locations"><a class="header" href="#locations">Locations</a></h2>
<p>This document is hosted online at <a href="https://rust-cli-recommendations.sunshowers.io">https://rust-cli-recommendations.sunshowers.io</a>. The source is hosted <a href="https://github.com/sunshowers-code/rust-cli-recommendations">on GitHub</a>.</p>
<p>This document is available offline by installing <code>git</code> and running the following command while online.</p>
<pre><code class="language-sh">git clone https://github.com/sunshowers-code/rust-cli-recommendations/ --branch gh-pages
</code></pre>
<p>then pointing your web browser to <code>rust-cli-recommendations/index.html</code>.</p>
<p>Issues containing recommendations and PRs are welcome! However, I get to make the final call: if your opinions diverge from mine, you're welcome to fork this project.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>This document, other than inline code snippets, is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>. This means that you are welcome to share or adapt this material as long as you give appropriate credit.</p>
<p>Code snippets included in this document are licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0 1.0</a>. The author(s) have waived all of their rights to the work worldwide under copyright law, to the extent allowed by law.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-listen-to-me"><a class="header" href="#why-listen-to-me">Why listen to me?</a></h1>
<p>I'm a reasonably proficient Rust developer, and have been using Rust professionally full-time since early 2017. I've also released the open source Rust CLI tools <a href="https://crates.io/crates/cargo-hakari">cargo-hakari</a> and <a href="https://crates.io/crates/cargo-search2">cargo-search2</a>, with more in development.</p>
<p>The list of recommendations is based on what I personally value most; however, most of these involve tradeoffs along a <a href="https://en.wikipedia.org/wiki/Pareto_efficiency">Pareto front</a>. Wherever possible, I provide a list of benefits and costs, and alternatives, to help you make an informed decision.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="picking-a-command-line-argument-parser"><a class="header" href="#picking-a-command-line-argument-parser">Picking a command-line argument parser</a></h1>
<p>When you're writing a Rust command-line application, one of the first things you'll have to do is to figure out how to parse command-line inputs.
There are a number of different command-line parsers for Rust programs. However, projects <em>should</em> use <a href="https://crates.io/crates/clap"><strong>clap</strong></a>.</p>
<p><strong>Why?</strong></p>
<ul>
<li>clap is actively maintained: as of January 2022, clap just came out with a <a href="">v3 release</a>.</li>
<li>clap is the most popular command-line parsing library for Rust, which means that there's an existing ecosystem of projects around clap.</li>
<li>clap comes with a number of extra features, such as suggestions based on <a href="https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance">Jaro–Winkler distance</a> and full configurability of <a href="https://docs.rs/clap/latest/clap/enum.AppSettings.html">commands</a> and <a href="https://docs.rs/clap/latest/clap/enum.ArgSettings.html">arguments</a></li>
<li>There are a number of standard conventions for Unix CLIs: see <a href="https://github.com/google/argh/issues/3#issuecomment-581144181">this comment</a> by <a href="https://github.com/ssokolow">Stephen Sokolow</a>. Another actively maintained project, <a href="https://github.com/google/argh">argh</a>, does not target Unix platforms and so does not support all of these conventions.</li>
</ul>
<p><strong>Why not?</strong></p>
<ul>
<li>clap pulls in several dependencies and takes quite a while to build.</li>
<li>clap increases binary size significantly.</li>
<li>clap is a complex parser with many different options, which can be overwhelming. I've found use for many of these options.</li>
<li>The latest version of clap as of January 2022 is 3.0.6. This version currently has a Minimum Supported Rust Version (MSRV) of Rust 1.54; I personally do not consider this to be a negative but there's <a href="https://github.com/clap-rs/clap/issues/3267">some discussions about it</a>. For now, a workaround is to use clap v2.</li>
</ul>
<h2 id="automatically-deriving-fields"><a class="header" href="#automatically-deriving-fields">Automatically deriving fields</a></h2>
<p>Projects <em>may</em> turn on the <code>derive</code> feature in clap and use a declarative model to define command-line arguments. (The <code>derive</code> feature is new to v3---users of clap v2 can use <a href="https://crates.io/crates/structopt">structopt</a>, which <code>clap_derive</code> is based on.)</p>
<p>For example:</p>
<pre><code class="language-rust noplaypen">use clap::Parser;

/// A very simple utility to search for a string across multiple files.
#[derive(Debug, Parser)]
pub struct GrepApp {
    /// Suppress normal output; instead print the name of each input file from which output
    /// would normally have been printed.  Scanning each input file stops upon first match.
    #[clap(long, short = &quot;l&quot;)]
    files_with_matches: bool,

    /// Search string
    search_str: String,

    /// Input files
    files: Vec&lt;String&gt;,
}
</code></pre>
<p>The doc comments are processed as help text by clap.</p>
<p><strong>Why?</strong></p>
<ul>
<li>Derive-style arguments are significantly easier to read, write, and modify.</li>
<li>Derive-style components can be written once, and reused across multiple commands.</li>
</ul>
<p><strong>Why not?</strong></p>
<ul>
<li>The derive macro is an optional feature that pulls in extra dependencies and increase build times.</li>
<li>The derive macro can be a bit magical. Looking at <a href="https://github.com/clap-rs/clap/blob/master/clap_derive/src/lib.rs">the source code of clap_derive</a> may be useful sometimes.</li>
</ul>
<h2 id="alternatives-to-clap"><a class="header" href="#alternatives-to-clap">Alternatives to clap</a></h2>
<ul>
<li><a href="https://github.com/google/argh">argh</a>: Google's argument parser. Actively maintained, but targets the Fuchsia OS rather than Unix platforms, so missing several crucial features.</li>
<li><a href="https://github.com/RazrFalcon/pico-args">pico-args</a>: Zero dependencies, quick to compile, and negligible impact on binary size. Does not include help generation, derive support, or as many config flags as clap. A great choice for really simple applications.</li>
<li><a href="https://crates.io/crates/gumdrop">gumdrop</a>: a simple argument parser with derive support. Somewhat less popular than clap, and doesn't support deserializing directly to domain types (clap <a href="https://github.com/clap-rs/clap/blob/v3.0.6/examples/derive_ref/README.md#arg-types">does</a>).</li>
<li>Writing your own by hand: you <em>should not</em> do this because there are a number of surprising footguns around argument parsing. Instead, use a simple parser like pico-args.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-arguments-and-subcommands"><a class="header" href="#handling-arguments-and-subcommands">Handling arguments and subcommands</a></h1>
<p>For a program that has subcommands, the following code structure is RECOMMENDED.</p>
<pre><code class="language-rust noplaypen">use camino::Utf8PathBuf;
use clap::{ArgEnum, Parser};

/// Help message for the app.
#[derive(Debug, Parser)]
pub struct App {
    #[clap(flatten)]
    global_opts: GlobalOpts,

    #[clap(subcommand)]
    command: Command,
}

#[derive(Debug, Parser)]
enum Command {
    /// Help message for read.
    Read {
        /// An example option
        #[clap(long, short)]
        opt: bool,

        /// The path to read from
        path: Utf8PathBuf,
    },
    /// Help message for write.
    Write {
        #[clap(flatten)]
        write_args: WriteArgs,
    },
    // ...other commands (can also #[clap(flatten)] other enums here)
}

#[derive(Debug, Parser)]
struct WriteArgs {
    /// The path to write to
    path: Utf8PathBuf,
    // a list of other write args
}

#[derive(Debug, Parser)]
struct GlobalOpts {
    /// Color
    #[clap(long, arg_enum, global = true, default_value_t = Color::Auto)]
    color: Color,

    /// Verbosity level (can be specified multiple times)
    #[clap(long, short, global = true, multiple_occurrences = true)]
    verbose: u64,

    //... other global options
}

#[derive(Clone, Debug, ArgEnum)]
enum Color {
    Always,
    Auto,
    Never,
}
</code></pre>
<p>Notes:</p>
<ul>
<li><strong>Only the top-level <code>App</code> is public.</strong></li>
<li><strong><code>App</code> is a struct, one level above the command enum.</strong>
<ul>
<li>While it is possible to make <code>App</code> an enum with all the subcommands, in my experience this design has always come back to bite me. This has always been because I've wanted to introduce global options later.</li>
</ul>
</li>
<li><strong>Liberal use of <code>#[clap(flatten)]</code>.</strong>
<ul>
<li>This option flattens inline options from a struct into the parent struct or enum variant, or from an enum into a parent enum.</li>
<li>This helps break up long series of options into smaller, reusable components that can be more easily processed in different sections of the project's code. For example, <code>Color</code> can be further nested into an <code>OutputOpts</code> struct, defined in a separate <code>output.rs</code> file.</li>
<li>It also helps code pass a complex set of arguments around as a single parameter, rather than having to add a parameter everywhere.</li>
</ul>
</li>
<li><strong>Global options are marked with <code>#[clap(global = true)]</code>.</strong>
<ul>
<li>This means that global options like <code>--color</code> can be used anywhere in the command line.</li>
</ul>
</li>
<li><strong>Use of <code>ArgEnum</code>.</strong>
<ul>
<li><code>ArgEnum</code> simplifies the definition of arguments that take one of a limited number of values.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binaries-vs-libraries"><a class="header" href="#binaries-vs-libraries">Binaries vs libraries</a></h1>
<p>You <em>may</em> expose your binary's functionality as a library.</p>
<p><strong>Why?</strong>
Some binaries are simple and don't necessarily need to expose their functionality as a library. Other binaries are more complex, in which case their functionality can be exposed as a library that others can build upon.</p>
<p>In any case, binary <em>crates</em> <em>should not</em> expose their library functionality within the same crate. The library, if exposed, <em>should</em> be a different crate, with an appropriate name linking the two. The library <em>should not</em> have any command-line parsing logic.</p>
<p><strong>Why?</strong></p>
<ul>
<li>For other consumers of the library, clap is an unnecessary dependency.</li>
<li>The binary's versioning is separated out from the library's versioning; see <a href="versioning.html">Versioning</a> for more.</li>
<li>Compile times become quicker.</li>
</ul>
<p><strong>Why not?</strong></p>
<ul>
<li>Maintaining a library in addition to a binary is hard work.</li>
<li>In some cases, maintainers can decide to expose their functionality <em>only</em> as a binary to force a looser coupling with downstream consumers.
<ul>
<li>Case study: The presence of the <a href="https://libgit2.org/">libgit2</a> and <a href="https://www.eclipse.org/jgit/">JGit</a> libraries for Git has made it significantly harder to improve Git's data structures. These libraries are tightly coupled to their consumers, which in practice means that Git improvements are tied to the release schedules of commercial projects like Xcode and Visual Studio.</li>
<li>Forced loose coupling can lead to greater development velocity.</li>
</ul>
</li>
</ul>
<h2 id="providing-an-ipc-interface"><a class="header" href="#providing-an-ipc-interface">Providing an IPC interface</a></h2>
<p>Applications <em>may</em> (and in the case of forced loose coupling, <em>should</em>) make their CLI available as an interface not just to humans but to other programs. In these cases, follow these rules:</p>
<ul>
<li>Programs <em>should</em> accept a <code>--message-format</code> flag, and <em>should</em> support at least <code>json</code> machine-readable output.</li>
<li>Programs <em>may</em> also provide their output as other formats like XML, <a href="https://cbor.io/">CBOR</a>, <a href="https://msgpack.org/index.html">MessagePack</a>, or other <strong>self-describing</strong> formats.
<ul>
<li>A self-describing format is one where the keys, or some equivalent, are part of the serialized output.</li>
<li>Formats like <a href="https://developers.google.com/protocol-buffers">protobuf</a> are suitable as well, if up-to-date IDLs (e.g. <code>.proto</code> files) are published along with releases. One neat trick is to embed them into your binary and add a command to write them out to a given directory.</li>
</ul>
</li>
<li>Programs <em>must not</em> provide their output as <a href="https://github.com/bincode-org/bincode">bincode</a> or other non-self-describing formats. These formats are unsuitable for inter-process communication where stability is paramount.</li>
<li>For greater compatibility with existing Unix tools like <code>xargs</code>, programs <em>may</em> provide list output as newline-delimited items.
<ul>
<li>If list items are filenames or can have newlines in them, programs <em>must</em> provide list output as null-delimited (<code>\0</code>-delimited) items. Almost all standard Unix commands understand null-delimited output (e.g. <code>xargs --null</code>).</li>
</ul>
</li>
<li>Colors <em>must</em> be disabled while writing to a pipe, unless <code>--color=always</code> is passed in. See <a href="./colors.html">Colors</a> for more.</li>
<li>Within a version series, output <em>must</em> be kept stable and append-only, and any breaking changes <em>must</em> be gated to an argument (e.g. <code>--format-version 2</code> or <code>--message-format json-v2</code>).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="versioning"><a class="header" href="#versioning">Versioning</a></h1>
<p>A library crate, if provided, <em>should</em> follow <a href="https://doc.rust-lang.org/cargo/reference/semver.html">the usual Rust library versioning rules</a>.</p>
<p>A binary crate <em>should not</em> follow those rules. Instead, the public API <em>should</em> consist of the command-line interface, plus anything else related to the interface that the project's maintainers wish to keep stable.</p>
<ul>
<li>This means that there should only be a major version change when there's a breaking change to the CLI.</li>
<li>For example, <a href="https://docs.rs/cargo-hakari/latest/cargo_hakari/#stability-guarantees">cargo-hakari's stability policy</a> is to keep the contents of a generated checked-in file the same, unless a config option is turned on or there's a bugfix.</li>
</ul>
<p><strong>Why?</strong> It is easier to avoid making breaking changes to command-line interfaces. Mature projects like <a href="https://www.gnu.org/software/coreutils/">GNU coreutils</a> avoid breaking changes to their CLIs for decades.</p>
<h2 id="tips-to-avoid-breaking-changes"><a class="header" href="#tips-to-avoid-breaking-changes">Tips to avoid breaking changes</a></h2>
<ul>
<li>Make experimental commands available via an environment variable or some other gating mechanism to gather feedback, with a warning that the behavior of these can change at any time.</li>
<li>Mark old commands or arguments deprecated, and possibly hide them from help text. Continue to preserve their behavior.</li>
<li>If the program persists data on disk, make it possible to do forward transitions but not backward ones. Add a <em>format version</em> to persisted data and increment it every time the data format changes. If an old version of the program reads a format version it does not understand, error out gracefully.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>Simple applications are able to accept all their options over the command line, but more complex ones eventually need to add support for configuration files.</p>
<h2 id="configuration-formats"><a class="header" href="#configuration-formats">Configuration formats</a></h2>
<p><strong>Configuration <em>should</em> be in the <a href="https://toml.io/en/">TOML format</a>.</strong> The TOML format, as a descendant of INI, is widely understood and is easy to read and write for both humans and computers.</p>
<p>Other configuration formats like <a href="https://yaml.org/">YAML</a> <em>may</em> be used if the configuration is extremely complex (though in these cases it's often fruitful to devise ways of reducing complexity), or if there are legacy constraints.</p>
<h2 id="configuration-scopes"><a class="header" href="#configuration-scopes">Configuration scopes</a></h2>
<p>Depending on the application, the following scopes for a configuration are often seen in practice:</p>
<ol>
<li><em>Directory-scoped.</em> Applies to a directory and its subdirectories. Controlled by a file somewhere in this directory or a parent. For example, <a href="https://git-scm.com/docs/gitignore"><code>.gitignore</code></a> is directory-scoped.</li>
<li><em>Repository-scoped.</em> Applies to a repository: controlled by a file somewhere in a code repository. For example, <a href="https://github.com/rust-lang/rust-clippy#configuration"><code>clippy.toml</code></a> is repository-scoped.</li>
<li><em>User-scoped.</em> A file somewhere in the user's home directory.</li>
<li><em>System-wide.</em> A file somewhere in a central location on the computer.</li>
</ol>
<p>Not all applications support all of these: which scopes make sense is a matter of judgment and thinking about use cases. Some server-side applications support fetching configuration from a remote server; they are out of scope here.</p>
<p><strong>If applications support repository-scoped configuration:</strong></p>
<ul>
<li>Applications <em>should</em> put repository-scoped configuration in a <code>.config</code> directory under the repository root. Typically, applications place their configuration at the top level of the repository. However, too many config files at the top level can pollute directory listings.</li>
<li>Applications <em>should</em> allow both local and checked-in configuration files. For example, an application <code>myapp</code> should support configuration in both <code>.config/myapp.toml</code> and <code>.config/myapp.local.toml</code>. Entries in <code>./config/myapp.local.toml</code> <em>must</em> override those in <code>.config/myapp.toml</code>.</li>
</ul>
<p><strong>If applications support user-specific configuration:</strong></p>
<ul>
<li>On Unix platforms other than macOS, applications <em>should</em> follow the <a href="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html">XDG specification</a>.</li>
<li>On macOS and Windows, applications <em>should</em> either use <code>$HOME/.config</code> or the native platform directory. On macOS and Windows, the platform-native directories are somewhat harder to access on the command line, so <code>$HOME/.config</code> is a suitable alternative.</li>
</ul>
<p><a href="https://crates.io/crates/dirs">dirs</a> is the most actively maintained Rust library for getting the native config directory (and other directories) for every platform.</p>
<p><strong>Applications <em>may</em> read configuration options over the command line and the environment.</strong> It is often reasonable to let users override configuration via command-line options and environment variables. If so, then:</p>
<ul>
<li>Environment variables <em>must</em> be prefixed with a unique identifier based on the app. For example, an app called <code>myapp</code> can support a &quot;limit&quot; configuration through a <code>MYAPP_LIMIT</code> variable.</li>
<li>Environment variables <em>should</em> also be supported as command-line options. For example, <code>myapp --limit</code>. Command-line options are more discoverable than environment variables. If you actually <em>want</em> your options to be less discoverable, for example if exposing them would increase support load, you can add hidden command-line options.</li>
<li>Command-line arguments <em>must</em> override environment variables. An environment variable can be set further up in the environment. A command-line argument expresses user intent most directly.</li>
</ul>
<h2 id="hierarchical-configuration"><a class="header" href="#hierarchical-configuration">Hierarchical configuration</a></h2>
<p><strong>Applications <em>should</em> follow a hierarchical configuration structure.</strong> Use the following order, from highest priority to lowest.</p>
<ol>
<li>Command-line arguments</li>
<li>Environment variables</li>
<li>Directory or repository-scoped configuration</li>
<li>User-scoped configuration</li>
<li>System-wide configuration</li>
<li>Default configuration shipped with the program.</li>
</ol>
<p><strong>Configurations <em>should</em> be merged rather than completely overwritten.</strong> Consider the following configuration files.</p>
<pre><code class="language-toml"># $HOME/.config/myapp.toml -- user-scoped config
limit = 42

[encoding]
input = &quot;utf16&quot;
output = &quot;utf32&quot;
</code></pre>
<pre><code class="language-toml"># &lt;repository&gt;/.config/myapp.toml -- repository-scoped config
limit = 84

[encoding]
input = &quot;utf8&quot;
</code></pre>
<p>The <em>merged</em> configuration is:</p>
<pre><code class="language-toml">[myapp]
limit = 84

[myapp.encoding]
input = &quot;utf8&quot;
output = &quot;utf32&quot;
</code></pre>
<p>Exactly what the boundaries of merged entries should be is application-specific: it is hard to give general guidance here.</p>
<h2 id="rust-libraries-for-managing-configuration"><a class="header" href="#rust-libraries-for-managing-configuration">Rust libraries for managing configuration</a></h2>
<p>There are two main Rust libraries for managing hierarchical configuration:</p>
<ul>
<li><a href="https://crates.io/crates/config">config</a>. I've used this and it seems to work well.</li>
<li><a href="https://crates.io/crates/figment">figment</a>. This seems quite nice as well, though I haven't used it.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-colors-to-applications"><a class="header" href="#adding-colors-to-applications">Adding colors to applications</a></h1>
<p>Colors can make your command-line applications look nice, and also make output easier to understand by leveraging human pattern recognition. However, adding them requires a significant amount of care.</p>
<h2 id="general-recommendations"><a class="header" href="#general-recommendations">General recommendations</a></h2>
<p>These rules apply to all command-line programs, not just Rust ones.</p>
<p><strong>Applications <em>should</em> follow this pattern:</strong></p>
<ol>
<li>A global <code>--color</code> option, with the values <code>always</code>, <code>auto</code> (default) and <code>never</code>. If this is specified as <code>always</code> or <code>never</code>, enable or disable colors respectively.</li>
<li>Otherwise, if one of a number of environment variables is specified, use what it says.</li>
<li>Otherwise, if the output stream (stdout or stderr) is a terminal (also called a &quot;tty&quot;), and the enable colors. Otherwise, disable them.</li>
</ol>
<p>2 and 3 are covered by the <a href="https://docs.rs/supports-color/latest/supports_color/">supports-color</a> Rust library. The exact set of environment variables is too complicated to describe here. See <a href="https://docs.rs/supports-color/latest/src/supports_color/lib.rs.html">the source code of supports-color</a> for a full list.</p>
<p><strong>It <em>must</em> be possible to disable colors.</strong> Some users's terminals may have broken color support; in some cases, pipe detection may not work as expected.</p>
<h2 id="color-palettes"><a class="header" href="#color-palettes">Color palettes</a></h2>
<p>Terminals may support one of three color palettes:</p>
<ul>
<li>Truecolor (16 million colors): 24-bit color; 8 bits for each of red, green and blue. This is the standard that web pages and most monitors support. You may have seen these colors written as e.g. <span style="color:#9b4fd1">#9b4fd1</span>.</li>
<li>256 colors: 18-bit color; 6 bits for each of red, green and blue. <a href="http://www.pixelbeat.org/docs/terminal_colours/#256">This page by Pádraig Brady</a> has more information about them.</li>
<li>16 colors: 4-bit color; black, red, green, yellow, blue, magenta, cyan, white, and a &quot;bright&quot; version of each.</li>
</ul>
<p><strong>The default color schemes in applications <em>must</em> be restricted to 12 colors: red, green, yellow, blue, magenta, cyan, and the bright versions of each of these.</strong></p>
<ul>
<li>While the wider palettes are useful for terminal theming controlled by the user, applications <em>should not</em> use them. The reason is that users may be using a variety of terminal themes with different backgrounds. <strong>Truecolors and 16-bit colors will not render properly with all terminal themes.</strong> For example, light-colored text will fade into a light background, or dark-colored text will fade into a dark background.</li>
<li>Most terminals allow you to configure these colors to whatever one pleases. In most themes, these 12 colors are set to contrast with the background.
<tt><span style="color: #acacab; background-color:#050505">Themes with dark backgrounds <span style="color: #a9cdeb">set &quot;blue&quot; to be lighter</span></span></tt>,
while <tt><span style="color: #0e0101; background-color:#ffffdd">themes with light backgrounds <span style="color: #3465a4">set &quot;blue&quot; to be darker</span></span></tt>. (These examples are from real themes.)</li>
<li>The &quot;black&quot; and &quot;white&quot; colors generally <em>do not</em> contrast with the background.</li>
</ul>
<p><strong>Applications <em>may</em> allow users to set their own color schemes.</strong> If users can set their own color schemes, like <a href="https://man7.org/linux/man-pages/man5/dir_colors.5.html">ls</a>, <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Colors.html">emacs</a> or <a href="https://vimhelp.org/usr_06.txt.html">vim</a> do, a wider range of colors can be supported. In these cases, users can match their color schemes with their terminal themes.</p>
<p><strong>Applications <em>may</em> use bold text.</strong> Almost all terminals support <strong>bold text</strong>. Some terminals do not support <em>italic text</em> or <del>strikethroughs</del>, so relying on them can cause issues.</p>
<p><strong>Applications <em>must not</em> use blinking text.</strong> Blinking text can be distracting or difficult to read for some people. The similar <code>&lt;blink&gt;</code> tag was <a href="https://www.fastcompany.com/3015408/saying-goodbye-to-the-html-tag">removed from web pages</a> around 2013.</p>
<h2 id="ansi-color-codes-and-windows-color-apis"><a class="header" href="#ansi-color-codes-and-windows-color-apis">ANSI color codes and Windows color APIs</a></h2>
<p>Most Unix terminals support <a href="https://en.wikipedia.org/wiki/ANSI_escape_code#Colors">ANSI color codes</a>. For example, turning the foreground color to &quot;green&quot; involves writing the characters <code>\x1b</code> (ESC), <code>[</code>, <code>32</code> (for green), and <code>m</code> to the terminal.</p>
<p>Historically, Windows provided a set of <a href="https://docs.microsoft.com/en-us/windows/console/console-screen-buffers#character-attributes">Console APIs</a> for the same purpose. These APIs have <a href="https://docs.microsoft.com/en-us/windows/console/classic-vs-vt">since been deprecated</a>, and Windows now supports the same ANSI color codes other platforms do.</p>
<p><strong>Cross-platform applications <em>should not</em> target the Windows Console APIs.</strong> Instead, they should rely on the ANSI color code support built into modern Windows terminals. Note that Windows requires ANSI color code support to be initialized: the <a href="https://github.com/sunshowers/enable-ansi-support">enable-ansi-support</a> crate does that for you if you're using Rust. Call it early in <code>main</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-colors-in-rust"><a class="header" href="#managing-colors-in-rust">Managing colors in Rust</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
